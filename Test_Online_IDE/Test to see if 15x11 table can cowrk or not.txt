
//
#define num_of_elevation_stamp 15
#define num_of_azimuth_stamp 	10
//#ifndef __SUNPOS_H
//#define __SUNPOS_H


// Declaration of some constants 
#define pi    3.14159//265358979323846
#define twopi (2*pi)
#define rad   (pi/180)
#define dEarthMeanRadius     6371.01	// In km
#define dAstronomicalUnit    149597890	// In km

struct cTime
{
	int iYear;
	int iMonth;
	int iDay;
	double dHours;
	double dMinutes;
	double dSeconds;
};

struct cLocation
{
	double dLongitude;
	double dLatitude;
};

struct cSunCoordinates
{
	double dZenithAngle;
	double dAzimuth;
};


double sunpos(struct cTime udtTime,struct cLocation udtLocation, struct cSunCoordinates *udtSunCoordinates);
struct point
{
	double x;
	double y;
};
unsigned char BCDtoDec1(unsigned char bcd)
{
	unsigned char hi,lo;
	hi=bcd>>4;
	lo=bcd&0x0F;
	return hi*10+lo;
}
double sunpos(struct cTime udtTime,struct cLocation udtLocation, struct cSunCoordinates *udtSunCoordinates)
{
	// Main variables
	double dElapsedJulianDays;
	double dDecimalHours;
	double dEclipticLongitude;
	double dEclipticObliquity;
	double dRightAscension;
	double dDeclination;

	// Auxiliary variables
	double dY;
	double dX;

	// Calculate difference in days between the current Julian Day 
	// and JD 2451545.0, which is noon 1 January 2000 Universal Time
	{
		double dJulianDate;
		long int liAux1;
		long int liAux2;
		// Calculate time of the day in UT decimal hours
		dDecimalHours = udtTime.dHours + (udtTime.dMinutes 
			+ udtTime.dSeconds / 60.0 ) / 60.0;
		// Calculate current Julian Day
		liAux1 =(udtTime.iMonth-14)/12;
		liAux2=(1461*(udtTime.iYear + 4800 + liAux1))/4 + (367*(udtTime.iMonth 
			- 2-12*liAux1))/12- (3*((udtTime.iYear + 4900 
		+ liAux1)/100))/4+udtTime.iDay-32075;
		dJulianDate=(double)(liAux2)-0.5+dDecimalHours/24.0;
		// Calculate difference between current Julian Day and JD 2451545.0 
		dElapsedJulianDays = dJulianDate-2451545.0;
	}

	// Calculate ecliptic coordinates (ecliptic longitude and obliquity of the 
	// ecliptic in radians but without limiting the angle to be less than 2*Pi 
	// (i.e., the result may be greater than 2*Pi)
	{
		double dMeanLongitude;
		double dMeanAnomaly;
		double dOmega;
		dOmega=2.1429-0.0010394594*dElapsedJulianDays;
		dMeanLongitude = 4.8950630+ 0.017202791698*dElapsedJulianDays; // Radians
		dMeanAnomaly = 6.2400600+ 0.0172019699*dElapsedJulianDays;
		dEclipticLongitude = dMeanLongitude + 0.03341607*sin( dMeanAnomaly ) 
			+ 0.00034894*sin( 2*dMeanAnomaly )-0.0001134
			-0.0000203*sin(dOmega);
		dEclipticObliquity = 0.4090928 - 6.2140e-9*dElapsedJulianDays
			+0.0000396*cos(dOmega);
	}

	// Calculate celestial coordinates ( right ascension and declination ) in radians 
	// but without limiting the angle to be less than 2*Pi (i.e., the result may be 
	// greater than 2*Pi)
	{
		double dSin_EclipticLongitude;
		dSin_EclipticLongitude= sin( dEclipticLongitude );
		dY = cos( dEclipticObliquity ) * dSin_EclipticLongitude;
		dX = cos( dEclipticLongitude );
		dRightAscension = atan2( dY,dX );
		if( dRightAscension < 0.0 ) dRightAscension = dRightAscension + twopi;
		dDeclination = asin( sin( dEclipticObliquity )*dSin_EclipticLongitude );
	}

	// Calculate local coordinates ( azimuth and zenith angle ) in degrees
	{
		double dGreenwichMeanSiderealTime;
		double dLocalMeanSiderealTime;
		double dLatitudeInRadians;
		double dHourAngle;
		double dCos_Latitude;
		double dSin_Latitude;
		double dCos_HourAngle;
		double dParallax;
		dGreenwichMeanSiderealTime = 6.6974243242 + 
			0.0657098283*dElapsedJulianDays 
			+ dDecimalHours;
		dLocalMeanSiderealTime = (dGreenwichMeanSiderealTime*15 
			+ udtLocation.dLongitude)*rad;
		dHourAngle = dLocalMeanSiderealTime - dRightAscension;
		dLatitudeInRadians = udtLocation.dLatitude*rad;
		dCos_Latitude = cos( dLatitudeInRadians );
		dSin_Latitude = sin( dLatitudeInRadians );
		dCos_HourAngle= cos( dHourAngle );
		udtSunCoordinates->dZenithAngle = (acos( dCos_Latitude*dCos_HourAngle
			*cos(dDeclination) + sin( dDeclination )*dSin_Latitude));
		dY = -sin( dHourAngle );
		dX = tan( dDeclination )*dCos_Latitude - dSin_Latitude*dCos_HourAngle;
		udtSunCoordinates->dAzimuth = atan2( dY, dX );
		if ( udtSunCoordinates->dAzimuth < 0.0 ) 
			udtSunCoordinates->dAzimuth = udtSunCoordinates->dAzimuth + twopi;
		udtSunCoordinates->dAzimuth = udtSunCoordinates->dAzimuth/rad;
		// Parallax Correction
		dParallax=(dEarthMeanRadius/dAstronomicalUnit)
			*sin(udtSunCoordinates->dZenithAngle);
		udtSunCoordinates->dZenithAngle=(udtSunCoordinates->dZenithAngle 
			+
 dParallax)/rad;
	}
	return dDeclination;
}
//#define Dai_to_JP_Zero 179;
//#define declination_offset -0.4829;// calculate from data of 31July2018
//#define time_offset -1.14;// calculate from data of 31July2018
double date_azimuth_mapping[num_of_azimuth_stamp]={180,190,200,210,220,230,240,250,260,270};
double low_date_azimuth_mapping[num_of_azimuth_stamp]={180,170,160,150,140,130,120,110,100,90};

//extern const char  num_of_elevation_stamp=15;
//double *RX_pos;
//RX_pos = (double*) malloc(1500*sizeof(double));

double RX_pos[num_of_elevation_stamp][num_of_azimuth_stamp]=
{

	
		{119.82,119.61,118.85,118.38,117.44,116.11,112.12,104.72,77.73,95.33},
		{106.97,106.89,106.1,104.28,101.42,96.98,89.29,72.01,30.52,-86.15},
		{94.51,94.09,92.61,89.79,85.79,78.15,65.61,40.49,-15.02,-109.61},
		{81.95,81.37,79.12,75.23,69.43,58.96,42.8,12.22,-43.92,-119.48},
		{69.21,68.33,65.65,60.64,52.70,40.47,21.29,-11.06,-62.79,-124.79},
		{55.32,54.53,51.56,45.96,37.10,23.17,1.94,-30.27,-74.81,-126.08},
		{41.98,40.93,37.55,31.48,20.77,6.45,-15.44,-45.27,-83.60,-127.40},
		{28.32,26.99,23.19,16.38,6.05,-9.18,-30.43,-57.46,-91.05,-127.83},
		{14.10,12.88,8.80,0.00,-8.48,-23.52,-43.02,-68.15,-96.90,-127.34},
		{0.00,0.00,-5.75,-12.18,-22.67,-36.63,-54.72,-76.88,-101.31,-127.73},
		{-14.17,-15.05,-19.14,-26.37,-36.22,-48.72,-65.47,-83.89,-105.09,-127.49},
		{-28.23,-29.54,-33.23,-39.61,-48.23,-60.09,-74.63,-90.88,-108.63,-127.54},
		{-42.13,-43.09,-46.37,-52.16,-60.35,-70.52,-82.69,-96.78,-111.79,-127.76},
		{-55.52,-56.40,-59.79,-65.01,-71.59,-80.18,-90.39,-101.91,-114.66,-127.95},
		{-69.05,-70.14,-72.41,-76.53,-82.19,-89.29,-97.69,-106.82,-117.03,-128.06}


	
};//

// Corrected sun time
double  elevation_stamp[num_of_elevation_stamp]={
	
2.2,
6.9,
11.6,
16.3,
21,
25.7,
30.4,
35.1,
39.8,
44.5,
49.2,
53.9,
58.6,
63.3,
68


};

/*double RX_pos_testttt[4][num_of_azimuth_stamp]=
{
		{-28.23,-29.54,-33.23,-39.61,-48.23,-60.09,-74.63,-90.88,-108.63,-127.54},
		{-42.13,-43.09,-46.37,-52.16,-60.35,-70.52,-82.69,-96.78,-111.79,-127.76},
		{-55.52,-56.40,-59.79,-65.01,-71.59,-80.18,-90.39,-101.91,-114.66,-127.95},
		{-69.05,-70.14,-72.41,-76.53,-82.19,-89.29,-97.69,-106.82,-117.03,-128.06}
};
double  elevation_stamp_testtttt[4]={

53.9,
58.6,
63.3,
68


};*/


double  linear_interpolate(struct point p1,struct point p2, double  x)
{
	double  fx;
	
	fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
	
	return fx;
}



void Update_position(unsigned char mnths,unsigned char dys,
										 unsigned char hurs,unsigned char mns,unsigned char sconds,
										 double  *currnt_pos, double offset_calib)
{
	unsigned int date,i=0,yy=0;
	//char num_of_elevation_stamp=15;
	double  desired_distance=0,distance=0,JP_pos=0;
	double  pos_interpolate_azimuth[num_of_azimuth_stamp],current_local_sun_time,azimuth, elevation,time_offset,UTC_time=-5;
	double declination;
	struct point p1,p2;
	struct cTime time1;
	struct cLocation location;
	struct cSunCoordinates *sunCoord;
	//hurs=hurs-1;// change to sun time
	//dys=dys+4;
	location.dLongitude=-73.59;
	location.dLatitude=45.51;
	time1.iYear=2019;
	time1.iMonth=BCDtoDec1(mnths);
	time1.iDay=BCDtoDec1(dys);
	time1.dHours=BCDtoDec1(hurs)+5;
	time1.dMinutes=BCDtoDec1(mns);
	time1.dSeconds=BCDtoDec1(sconds&0x7f);

	
	desired_distance=*currnt_pos;
	
	//date=Day_Of_Year(mnths,dys)+4;
	//date=237;
	declination=sunpos(time1,location,&sunCoord)*180/pi;//+declination_offset;
	time_offset=(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(time1.iDay-81)/365)*pi/180)    -    7.53*cos((360*(time1.iDay-81)/365)*pi/180)    -   1.5*sin((360*(time1.iDay-81)/365)*pi/180))/60;
	current_local_sun_time=(double) (BCDtoDec1(hurs))+(double)BCDtoDec1(mns)/60+time_offset;//-1;//current time=sun time= clock time -1
	//=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
	elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
						cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180)           );
	azimuth=180+(180/pi)*asin(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((90-elevation)*pi/180)          );// JP calculation
	//azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((90-elevation)*pi/180)          );// JP calculation

	
	//if (current_local_sun_time>12)
	//	azimuth=360-azimuth;
	
	if(BCDtoDec1(sconds&0x7f)%2==0)
	{
		// interpolate for azimuth
		for (i=0;i<num_of_azimuth_stamp;i++)
		{
			if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
			{
				for (yy=0;yy<num_of_elevation_stamp;yy++)
				{
					p1.x=date_azimuth_mapping[i];
					p2.x=date_azimuth_mapping[i+1];
					
					p1.y=RX_pos[yy][i];
					p2.y=RX_pos[yy][i+1];
					
					pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
				}
				//break;
			}
			
			else if ((azimuth>=low_date_azimuth_mapping[i+1]) && (azimuth<=low_date_azimuth_mapping[i]))
			{
				for (yy=0;yy<num_of_elevation_stamp;yy++)
				{
					p1.x=low_date_azimuth_mapping[i];
					p2.x=low_date_azimuth_mapping[i+1];
					
					p1.y=RX_pos[yy][i];
					p2.y=RX_pos[yy][i+1];
					
					pos_interpolate_azimuth[yy]=linear_interpolate(p2,p1,azimuth);
				}
				//break;
			}
		}

		// interpolate for elevation
		for(i=0;i<num_of_elevation_stamp;i++)
		{
			if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
			{
				p1.x=elevation_stamp[i];
				p2.x=elevation_stamp[i+1];
				
				p1.y=pos_interpolate_azimuth[i];
				p2.y=pos_interpolate_azimuth[i+1];
				
				JP_pos=linear_interpolate(p1,p2,elevation);
				//break;
				
			}
			
		}
		
		desired_distance=JP_pos+71+offset_calib;
		//desired_distance=elevation;
		distance=desired_distance-*currnt_pos;
		//if(abs(distance)>=0.5 && desired_distance>=-15 &&desired_distance<=210 )// move if the change is more than 0.5mm
		{
			/*if(distance>0)
				Move(distance,1);
			else if (distance<0)
				Move(-distance,0);*/
			//previous_move_time=BCDtoDec1(sconds&0x7f);
			*currnt_pos=desired_distance;
		}
	}
	return;

}
void main(void)
{	
    double current_position=0;
    Update_position(0x01,0x22,0x12,0x00,0x02,&current_position,0);
    printf("%f",current_position);
}