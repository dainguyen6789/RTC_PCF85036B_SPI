/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/
#define num_of_time_stamp 11
#define num_of_day_stamp 	10
#define Dai_to_JP_Zero 179;
#define pi    3.14159265358979323846
#define twopi (2*pi)
#define rad   (pi/180)
#define dEarthMeanRadius     6371.01	// In km
#define dAstronomicalUnit    149597890	// In km

struct cTime
{
	int iYear;
	int iMonth;
	int iDay;
	 float dHours;
	 float dMinutes;
	 float dSeconds;
};

struct cLocation
{
	 float dLongitude;
	 float dLatitude;
};

struct cSunCoordinates
{
	 float dZenithAngle;
	 float dAzimuth;
};
 float date_declination_mapping[num_of_day_stamp]={23.4400,21.0960,18.7520,14.0640,11.7200,9.3760,7.0320,4.6880,2.3440,0.0000};

 float RX_pos[num_of_time_stamp][num_of_day_stamp]=
{
	{-70.88,-64.14,-57.32,-43.59,-36.61,-29.59,-22.37,-15.12,-7.63,0.00},
	{-71.38,-64.61,-57.76,-43.91,-36.95,-29.82,-22.54,-15.23,-7.70,0.00},
	{-72.94,-66.07,-59.09,-44.98,-37.80,-30.56,-23.12,-15.62,-7.92,0.00},
	{-75.69,-68.60,-61.41,-46.82,-39.40,-31.83,-24.11,-16.31,-8.29,0.00},
	{-79.80,-72.39,-64.90,-49.61,-41.81,-33.77,-25.61,-17.33,-8.85,0.00},
	{-85.48,-77.82,-69.89,-53.61,-45.20,-36.65,-27.84,-18.76,-9.54,0.00},
	{-93.49,-85.30,-76.91,-59.25,-50.12,-40.64,-30.97,-20.94,-10.68,0.00},
	{-104.22,-95.65,-86.67,-67.37,-57.21,-46.55,-35.57,-24.10,-12.21,0.00},
	{-118.82,-109.96,-100.47,-79.29,-67.62,-55.49,-42.47,-28.94,-14.62,0.00},
	{-138.85,-130.17,-120.40,-97.58,-84.24,-69.67,-53.95,-37.07,-18.80,0.00},
	{-165.88,-158.21,-149.23,-126.45,-111.78,-95.01,-75.17,-52.58,-27.24,0.00}
};
// Corrected sun time
 float  Time_stamp_PM[num_of_time_stamp]={
11.94,
12.44,
12.94,
13.44,
13.94,
14.44,
14.94,
15.44,
15.94,
16.44,
16.94,
};
/* float  Time_stamp_PM[num_of_time_stamp]={
12,
12.5,
13,
13.5,
14,
14.5,
15,
15.5,
16,
16.5,
17,
};*/
struct point
{
	 float x;
	 float y;
};
  float  findDet3x3( 
             float  a11,  float  a12,  float  a13, 
             float  a21,  float  a22,  float  a23,
             float  a31,  float  a32,  float  a33 )
{
		return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
						a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
}

unsigned char BCDtoDec1(unsigned char bcd)
{
	unsigned char hi,lo;
	hi=bcd>>4;
	lo=bcd&0x0F;
	return hi*10+lo;
}
//===================================================== 
 float  linear_interpolate(struct point p1,struct point p2,  float  x)
{
	 float  fx;
	
	fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
	
	return fx;
}

// 	2nd order interpolate: 
//	input 3 points p1,p2,p3 and desired x value
// 	output: f(x)
 float second_order_interpolate(struct point p1,struct point p2, struct point p3,  float  x)
{
	// float a,b,c;// fx=ax^2+bx+c
	 float det,det_x,det_y,det_z,fx;
	
	det=findDet3x3(pow(p1.x,2) ,p1.x ,1 ,  pow(p2.x,2) ,p2.x ,1 ,   pow(p3.x,2) ,p3.x ,1 );
	
	det_x=findDet3x3(p1.y ,p1.x ,1 ,  p2.y ,p2.x ,1 ,   p3.y ,p3.x ,1 );
	
	det_y=findDet3x3(pow(p1.x,2) ,p1.y ,1 ,  pow(p2.x,2) ,p2.y ,1 ,   pow(p3.x,2) ,p3.y ,1 );
	
	det_z=findDet3x3(pow(p1.x,2) ,p1.x ,p1.y ,  pow(p2.x,2) ,p2.x ,p2.y ,   pow(p3.x,2) ,p3.x ,p3.y );
	if(det!=0)
		//fx=det_x*pow(x,2)/det+det_y*x/det+det_z/det;
				fx=det_x/det*pow(x,2)+det_y/det*x+det_z/det;

	else
		fx=0;
		
	return fx;
}
 float sunpos(struct cTime udtTime,struct cLocation udtLocation, struct cSunCoordinates *udtSunCoordinates)
{
	// Main variables
	 float dElapsedJulianDays;
	 float dDecimalHours;
	 float dEclipticLongitude;
	 float dEclipticObliquity;
	 float dRightAscension;
	 float dDeclination;

	// Auxiliary variables
	 float dY;
	 float dX;

	// Calculate difference in days between the current Julian Day 
	// and JD 2451545.0, which is noon 1 January 2000 Universal Time
	{
		 float dJulianDate;
		long int liAux1;
		long int liAux2;
		// Calculate time of the day in UT decimal hours
		dDecimalHours = udtTime.dHours + (udtTime.dMinutes 
			+ udtTime.dSeconds / 60.0 ) / 60.0;
		// Calculate current Julian Day
		liAux1 =(udtTime.iMonth-14)/12;
		liAux2=(1461*(udtTime.iYear + 4800 + liAux1))/4 + (367*(udtTime.iMonth 
			- 2-12*liAux1))/12- (3*((udtTime.iYear + 4900 
		+ liAux1)/100))/4+udtTime.iDay-32075;
		dJulianDate=(double)(liAux2)-0.5+dDecimalHours/24.0;
		// Calculate difference between current Julian Day and JD 2451545.0 
		dElapsedJulianDays = dJulianDate-2451545.0;
	}

	// Calculate ecliptic coordinates (ecliptic longitude and obliquity of the 
	// ecliptic in radians but without limiting the angle to be less than 2*Pi 
	// (i.e., the result may be greater than 2*Pi)
	{
		 float dMeanLongitude;
		 float dMeanAnomaly;
		 float dOmega;
		dOmega=2.1429-0.0010394594*dElapsedJulianDays;
		dMeanLongitude = 4.8950630+ 0.017202791698*dElapsedJulianDays; // Radians
		dMeanAnomaly = 6.2400600+ 0.0172019699*dElapsedJulianDays;
		dEclipticLongitude = dMeanLongitude + 0.03341607*sin( dMeanAnomaly ) 
			+ 0.00034894*sin( 2*dMeanAnomaly )-0.0001134
			-0.0000203*sin(dOmega);
		dEclipticObliquity = 0.4090928 - 6.2140e-9*dElapsedJulianDays
			+0.0000396*cos(dOmega);
	}

	// Calculate celestial coordinates ( right ascension and declination ) in radians 
	// but without limiting the angle to be less than 2*Pi (i.e., the result may be 
	// greater than 2*Pi)
	{
		 float dSin_EclipticLongitude;
		dSin_EclipticLongitude= sin( dEclipticLongitude );
		dY = cos( dEclipticObliquity ) * dSin_EclipticLongitude;
		dX = cos( dEclipticLongitude );
		dRightAscension = atan2( dY,dX );
		if( dRightAscension < 0.0 ) dRightAscension = dRightAscension + twopi;
		dDeclination = asin( sin( dEclipticObliquity )*dSin_EclipticLongitude );
	}

	// Calculate local coordinates ( azimuth and zenith angle ) in degrees
	{
		 float dGreenwichMeanSiderealTime;
		 float dLocalMeanSiderealTime;
		 float dLatitudeInRadians;
		 float dHourAngle;
		 float dCos_Latitude;
		 float dSin_Latitude;
		 float dCos_HourAngle;
		 float dParallax;
		dGreenwichMeanSiderealTime = 6.6974243242 + 
			0.0657098283*dElapsedJulianDays 
			+ dDecimalHours;
		dLocalMeanSiderealTime = (dGreenwichMeanSiderealTime*15 
			+ udtLocation.dLongitude)*rad;
		dHourAngle = dLocalMeanSiderealTime - dRightAscension;
		dLatitudeInRadians = udtLocation.dLatitude*rad;
		dCos_Latitude = cos( dLatitudeInRadians );
		dSin_Latitude = sin( dLatitudeInRadians );
		dCos_HourAngle= cos( dHourAngle );
		udtSunCoordinates->dZenithAngle = (acos( dCos_Latitude*dCos_HourAngle
			*cos(dDeclination) + sin( dDeclination )*dSin_Latitude));
		dY = -sin( dHourAngle );
		dX = tan( dDeclination )*dCos_Latitude - dSin_Latitude*dCos_HourAngle;
		udtSunCoordinates->dAzimuth = atan2( dY, dX );
		if ( udtSunCoordinates->dAzimuth < 0.0 ) 
			udtSunCoordinates->dAzimuth = udtSunCoordinates->dAzimuth + twopi;
		udtSunCoordinates->dAzimuth = udtSunCoordinates->dAzimuth/rad;
		// Parallax Correction
		dParallax=(dEarthMeanRadius/dAstronomicalUnit)
			*sin(udtSunCoordinates->dZenithAngle);
		udtSunCoordinates->dZenithAngle=(udtSunCoordinates->dZenithAngle 
			+
 dParallax)/rad;
	}
	return dDeclination;
}
 float Update_position(unsigned char mnths,unsigned char dys,
										 unsigned char hurs,unsigned char mns,unsigned char sconds,
										  float  *currnt_pos)
{
	unsigned int date,i,yy;
	 float  desired_distance,distance=0,JP_pos;
	 float  pos_interpolate_12_17h[num_of_time_stamp],current_time;
	 float declination;
	struct point p1,p2,p3;
	struct cTime time1;
	struct cLocation location;
	struct cSunCoordinates *sunCoord;
	hurs=hurs-1;// change to sun time
	//dys=dys+4;// shift 4 days because of Jean Phillip
	time1.iYear=2018;
	time1.iMonth=BCDtoDec1(mnths);
	time1.iDay=BCDtoDec1(dys);
	time1.dHours=BCDtoDec1(hurs);
	time1.dMinutes=BCDtoDec1(mns);
	time1.dSeconds=BCDtoDec1(sconds&0x7f);

	
	desired_distance=*currnt_pos;
	//date=Day_Of_Year(mnths,dys);
	//date=237;
	declination=sunpos(time1,location,&sunCoord)*180/pi;
	
	current_time=(float) BCDtoDec1(hurs)+(float)BCDtoDec1(mns)/60+(float)BCDtoDec1(sconds&0x7f)/3600;

	// interpolate for day
		for (i=0;i<num_of_day_stamp;i++)
		{
			if (declination<=date_declination_mapping[i] && declination>=date_declination_mapping[i+1])
			{
				for (yy=0;yy<num_of_time_stamp;yy++)
				{
					p1.x=date_declination_mapping[i];
					p2.x=date_declination_mapping[i+1];
					
					p1.y=RX_pos[yy][i];
					p2.y=RX_pos[yy][i+1];
					if (i>0 && i<8)
					{
						if(   (declination-date_declination_mapping[i+1]) > (date_declination_mapping[i]-declination)   )
						{
							p3.x=date_declination_mapping[i-1];
							p3.y=RX_pos[yy][i-1];;
						}
						else
						{
							p3.x=date_declination_mapping[i+2];
							p3.y=RX_pos[yy][i+2];;
						}
					}
					if(i==0)
					{
							p3.x=date_declination_mapping[i+2];
							p3.y=RX_pos[yy][i+2];;
					}
					if(i==8)
					{
							p3.x=date_declination_mapping[i-1];
							p3.y=RX_pos[yy][i-1];;
					}
					pos_interpolate_12_17h[yy]=second_order_interpolate(p1,p2,p3,declination);
				}
				break;
			}
		}

		// interpolate for hour
		for(i=0;i<num_of_time_stamp;i++)
		{
			if(current_time>=Time_stamp_PM[i]&&current_time<=Time_stamp_PM[i+1] && BCDtoDec1(sconds&0x7f)%30==0)
			{
				p1.x=Time_stamp_PM[i];
				p2.x=Time_stamp_PM[i+1];
				
				p1.y=pos_interpolate_12_17h[i];
				p2.y=pos_interpolate_12_17h[i+1];
				if(!i)// i==0
				{
					p3.x=Time_stamp_PM[i+2];
					p3.y=pos_interpolate_12_17h[i+2];
					
				}
				else if(i==(num_of_time_stamp-1))
				{
					p3.x=Time_stamp_PM[i-1];
					p3.y=pos_interpolate_12_17h[i-1];
				}
				else
				{
					if(   (current_time-Time_stamp_PM[i])>=(Time_stamp_PM[i+1]-current_time)   )
					{
							p3.x=Time_stamp_PM[i+2];
							p3.y=pos_interpolate_12_17h[i+2];
					}
					else
					{
							p3.x=Time_stamp_PM[i-1];
							p3.y=pos_interpolate_12_17h[i-1];
					}
				}
				
				JP_pos=second_order_interpolate(p2,p1,p3,current_time);
				break;
				
			}
			
		}
		
	desired_distance=179+2*JP_pos;
		
	distance=desired_distance-*currnt_pos;
	
	*currnt_pos=desired_distance;
	return pos_interpolate_12_17h[0];

}

int main()
{
     float *current_position;
     float x;
    struct cTime timee;
    struct cLocation locat;
    struct cSunCoordinates *sun;
     float decli;
    timee.iYear=2018;
	timee.iMonth=8;
	
	timee.iDay=22;
	timee.dHours=12;
	timee.dMinutes=0;
	timee.dSeconds=0;
	locat.dLongitude=1;
	locat.dLatitude=1;

    printf("Hello World");
    x=Update_position(0x08,0x22,0x13,0x30,0x00,&current_position);
    //x=*current_position;
    printf("%f",x);
    return 0;
}