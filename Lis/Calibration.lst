C51 COMPILER V9.52.0.0   CALIBRATION                                                       01/18/2019 12:52:24 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CALIBRATION
OBJECT MODULE PLACED IN .\Obj\Calibration.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Calibration.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXTE
                    -ND PRINT(.\Lis\Calibration.lst) TABS(2) OBJECT(.\Obj\Calibration.obj)

line level    source

   1          //#include "ADCh.h"
   2          #include "stc15f2k60s2.h"
   3          #include <stdio.h>
   4          #include <stdlib.h>
   5          #include "ADCh.h"
   6          void Wait_ms(int ms);
   7          unsigned int ADC_GetResult(unsigned char ch);
   8          void Move(float  distance, bit direction);
   9          unsigned int Max_Value(unsigned int *input);
  10          void Update_position(unsigned char mnths,unsigned char dys,
  11                               unsigned char hurs,unsigned char mns,unsigned char sconds,
  12                               float  *currnt_pos, float offset_calib);
  13          unsigned int Day_Of_Year(unsigned char months_bcd,unsigned char days_bcd); // this function is used to cou
             -nt the date in a year example: 22 March is the 80th day of the year
  14          
  15          // read adc ch to sense the voltage of the solar panel.     
  16          
  17          int voltage_is_stable(void)
  18          {
  19   1        unsigned int sample_voltage[10];
  20   1        int i,ch=0;
  21   1        for (i=0; i<10;i++)
  22   1        {
  23   2              sample_voltage[i]=ADC_GetResult(ch);
  24   2        }
  25   1        
  26   1        for(i=1;i<=9;i++)
  27   1        {
  28   2              if(abs(sample_voltage[i]-sample_voltage[0])>ADC_Stable_Threshold)
  29   2                return 0;
  30   2        }
  31   1        return 1;
  32   1      }
  33          void  Find_Real_Max(float  *current_position)
  34          {
  35   1        unsigned char ch=0;
  36   1        float calib_step_move=0.5;
  37   1        unsigned int voltage_at_scanned_pos[41],max_location;
  38   1        int i;
  39   1        voltage_at_scanned_pos[0]=*current_position+10;// this is JP theory max position
  40   1        // move/scan +direction
  41   1        for(i=1;i<=40;i++)
  42   1        {
  43   2          Move(calib_step_move,1);
  44   2          *current_position=*current_position+0.5;
  45   2          voltage_at_scanned_pos[i]=ADC_GetResult(ch);
  46   2          Wait_ms(1500);
  47   2        }
  48   1        // go back to JP max theorical position
  49   1      /*    Move(10,0);
  50   1          *current_position=*current_position-10; 
  51   1          Wait_ms(500);
  52   1        // move/scan -direction
  53   1        for (i=1;i<=20;i++)
C51 COMPILER V9.52.0.0   CALIBRATION                                                       01/18/2019 12:52:24 PAGE 2   

  54   1        {
  55   1      
  56   1            Move(calib_step_move,1);
  57   1            *current_position=*current_position+0.5;
  58   1            voltage_at_scanned_pos[i]=ADC_GetResult(ch);
  59   1            Wait_ms(500);
  60   1        }*/
  61   1        
  62   1        max_location=Max_Value(voltage_at_scanned_pos);//max_location in an array [0,...,39]
  63   1        // move to the optimal position in the area of +/-10mm from JP max theorical pos
  64   1        if(max_location!=0)
  65   1        {
  66   2          Move(calib_step_move*(40-max_location),0);
  67   2          *current_position=*current_position-calib_step_move*(40-max_location);
  68   2          Wait_ms(500);
  69   2        }
  70   1        else
  71   1        {
  72   2            Move(calib_step_move*(20-max_location),0);
  73   2            *current_position=*current_position-calib_step_move*(20-max_location);
  74   2            Wait_ms(500);
  75   2        }
  76   1      
  77   1      }
  78          
  79          
  80          unsigned int Max_Value(unsigned int *input)
  81          {
  82   1        unsigned int max,max_location=0,i;
  83   1        //int i;
  84   1        for(i=0;i<=40;i++)
  85   1        {
  86   2          max=max>*(input+i)? max:*(input+i);
  87   2          if (max==*(input+i))
  88   2            max_location=i;
  89   2        }
  90   1        return max_location;// pos in the array
  91   1        
  92   1      }
  93          //input currnt_pos is the JP max theorical position
  94          float calibration(unsigned char mnths,unsigned char dys,
  95                               unsigned char hurs,unsigned char mns,unsigned char sconds,
  96                               float  *currnt_pos)
  97          {
  98   1        float calib_value=0;
  99   1        float JP_max_pos=*currnt_pos;
 100   1        // if voltage is stable 
 101   1        if(voltage_is_stable())
 102   1        {
 103   2          //  move to JP theorical max position
 104   2          Update_position(mnths,dys,hurs,mns,sconds,&JP_max_pos,-10);// off set is Zero means we go to  (JP max th
             -eorical position -10)
 105   2          //  find the real max value in the area of JP +/- 10mm
 106   2          Find_Real_Max(&JP_max_pos); //find real max and move to real max position
 107   2          calib_value=*currnt_pos-JP_max_pos;
 108   2          *currnt_pos=JP_max_pos;
 109   2          return calib_value;
 110   2        }
 111   1        else
 112   1          return 0;
 113   1      }

C51 COMPILER V9.52.0.0   CALIBRATION                                                       01/18/2019 12:52:24 PAGE 3   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    969    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     138
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
