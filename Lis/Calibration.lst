C51 COMPILER V9.52.0.0   CALIBRATION                                                       11/02/2018 12:04:45 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CALIBRATION
OBJECT MODULE PLACED IN .\Obj\Calibration.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Calibration.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXTE
                    -ND PRINT(.\Lis\Calibration.lst) TABS(2) OBJECT(.\Obj\Calibration.obj)

line level    source

   1          //#include "ADCh.h"
   2          #include "stc15f2k60s2.h"
   3          #include <stdio.h>
   4          #include <stdlib.h>
   5          #include "ADCh.h"
   6          void Wait_ms(int ms);
   7          unsigned int ADC_GetResult(unsigned char ch);
   8          void Move(float  distance, bit direction);
   9          unsigned int Max_Value(unsigned int *input);
  10          void Update_position(unsigned char mnths,unsigned char dys,
  11                               unsigned char hurs,unsigned char mns,unsigned char sconds,
  12                               float  *currnt_pos, float offset_calib,float  *currnt_angle);
  13          unsigned int Day_Of_Year(unsigned char months_bcd,unsigned char days_bcd); // this function is used to cou
             -nt the date in a year example: 22 March is the 80th day of the year
  14          
  15          // read adc ch to sense the voltage of the solar panel.     
  16          
  17          int voltage_is_stable(void)
  18          {
  19   1        unsigned int sample_voltage[10];
  20   1        int i,ch=0;
  21   1        for (i=0; i<10;i++)
  22   1        {
  23   2              sample_voltage[i]=ADC_GetResult(ch);
  24   2        }
  25   1        
  26   1        for(i=1;i<=9;i++)
  27   1        {
  28   2              if(abs(sample_voltage[i]-sample_voltage[0])>ADC_Stable_Threshold)
  29   2                return 0;
  30   2        }
  31   1        return 1;
  32   1      }
  33          void  Find_Real_Max(float  *current_position)
  34          {
  35   1        unsigned char ch=0;
  36   1        float calib_step_move=0.5;
  37   1        unsigned int voltage_at_scanned_pos[40],max_location;
  38   1        int i;
  39   1        // move/scan +direction
  40   1        for(i=1;i<=20;i++)
  41   1        {
  42   2          Move(calib_step_move,1);
  43   2          *current_position=*current_position+0.5;
  44   2          voltage_at_scanned_pos[20+i]=ADC_GetResult(ch);
  45   2          Wait_ms(500);
  46   2        }
  47   1        // go back to JP max theorical position
  48   1          Move(10,0);
  49   1          *current_position=*current_position-10; 
  50   1          Wait_ms(500);
  51   1        // move/scan -direction
  52   1        for (i=1;i<=20;i++)
  53   1        {
C51 COMPILER V9.52.0.0   CALIBRATION                                                       11/02/2018 12:04:45 PAGE 2   

  54   2      
  55   2            Move(calib_step_move,0);
  56   2            *current_position=*current_position-0.5;
  57   2            voltage_at_scanned_pos[i]=ADC_GetResult(ch);
  58   2            Wait_ms(500);
  59   2        }
  60   1        
  61   1        max_location=Max_Value(voltage_at_scanned_pos);//max_location in an array [0,...,39]
  62   1        // move to the optimal position in the area of +/-10mm from JP max theorical pos
  63   1        Move(calib_step_move*max_location,1);
  64   1        *current_position=*current_position+calib_step_move*max_location;
  65   1        Wait_ms(500);
  66   1      
  67   1      }
  68          
  69          
  70          unsigned int Max_Value(unsigned int *input)
  71          {
  72   1        unsigned int max,max_location=0,i;
  73   1        //int i;
  74   1        for(i=0;i<=39;i++)
  75   1        {
  76   2          max=max>*(input+i)? max:*(input+i);
  77   2          if (max==*(input+i))
  78   2            max_location=i;
  79   2        }
  80   1        return max_location;// pos in the array
  81   1        
  82   1      }
  83          //input currnt_pos is the JP max theorical position
  84          float calibration(unsigned char mnths,unsigned char dys,
  85                               unsigned char hurs,unsigned char mns,unsigned char sconds,
  86                               float  *currnt_pos)
  87          {
  88   1        float calib_value=0;
  89   1        float JP_max_pos=*currnt_pos;
  90   1        // if voltage is stable 
  91   1        if(voltage_is_stable())
  92   1        {
  93   2          //  move to JP theorical max position
  94   2          Update_position(mnths,dys,hurs,mns,sconds,&JP_max_pos,0,0);// off set is Zero means we go to the JP max 
             -theorical position
  95   2          //  find the real max value in the area of JP +/- 10mm
  96   2          Find_Real_Max(&JP_max_pos); //find real max and move to real max position
  97   2          calib_value=*currnt_pos-JP_max_pos;
  98   2          *currnt_pos=JP_max_pos;
  99   2          return calib_value;
 100   2        }
 101   1        else
 102   1          return 0;
 103   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1054    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     136
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.52.0.0   CALIBRATION                                                       11/02/2018 12:04:45 PAGE 3   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
