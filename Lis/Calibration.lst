C51 COMPILER V9.52.0.0   CALIBRATION                                                       05/14/2019 16:10:22 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CALIBRATION
OBJECT MODULE PLACED IN .\Obj\Calibration.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Calibration.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXTE
                    -ND PRINT(.\Lis\Calibration.lst) TABS(2) OBJECT(.\Obj\Calibration.obj)

line level    source

   1          //#include "ADCh.h"
   2          #include "stc15f2k60s2.h"
   3          #include <stdio.h>
   4          #include <stdlib.h>
   5          #include "ADCh.h"
   6          #include "AT25SF041.h"
   7          #include "SI1120.h"
   8          #define  offset_error 0.8
   9          
  10          void Wait_ms(int ms);
  11          unsigned int ADC_GetResult(unsigned char ch);
  12          void Move(float  distance, bit direction);
  13          unsigned int Max_Value(unsigned int *input);
  14          void Update_position(unsigned char mnths,unsigned char dys,
  15                               unsigned char hurs,unsigned char mns,unsigned char sconds,
  16                               float  *currnt_pos, float offset_calib);
  17          unsigned int Day_Of_Year(unsigned char months_bcd,unsigned char days_bcd); // this function is used to cou
             -nt the date in a year example: 22 March is the 80th day of the year
  18          void WriteData(unsigned char dat);
  19          void Command(unsigned char dat);//dat=0x0X
  20          void Display_Pos(float sign_dat);
  21          // read adc ch to sense the voltage of the solar panel.     
  22          
  23          int voltage_is_stable(void)
  24          {
  25   1        unsigned int sample_voltage[10];
  26   1        int i,ch=0;
  27   1        for (i=0; i<10;i++)
  28   1        {
  29   2              sample_voltage[i]=ADC_GetResult(ch);
  30   2        }
  31   1        
  32   1        for(i=1;i<=9;i++)
  33   1        {
  34   2              if(abs(sample_voltage[i]-sample_voltage[0])>ADC_Stable_Threshold)
  35   2                return 0;
  36   2        }
  37   1        return 1;
  38   1      }
  39          void  Find_Real_Max(float  *current_position, unsigned int *calib_max_ADC_Value,unsigned int *max_ADC_JP_v
             -alue, unsigned long int *address_to_write)
  40          {
  41   1          unsigned char ch=0;
  42   1          float calib_step_move=0.5;
  43   1          //float offset_error=0.8;
  44   1          unsigned int voltage_at_scanned_pos[81],max_location, avg_voltage=0;
  45   1          int i,j;
  46   1          //float offset_error=0.8;
  47   1          // move/scan +`
  48   1          for(i=0;i<81;i++)// 81 values
  49   1          {
  50   2            voltage_at_scanned_pos[i]=0;
  51   2          }
  52   1          for(i=0;i<81;i++)
C51 COMPILER V9.52.0.0   CALIBRATION                                                       05/14/2019 16:10:22 PAGE 2   

  53   1          {
  54   2              //if(ADC_GetResult(2)>=sunlight_ADC_Threshold)
  55   2              {
  56   3                //avg_voltage=0;
  57   3                for(j=0;j<5;j++)
  58   3                {
  59   4                  if(j==0)
  60   4                  {
  61   5                    avg_voltage=0;
  62   5                  }
  63   4                  avg_voltage+=ADC_GetResult(ch);
  64   4                  Wait_ms(2);
  65   4      
  66   4                }
  67   3                voltage_at_scanned_pos[i]=avg_voltage/5;
  68   3      
  69   3                //  Because the uC Flash Memory is almost full, 
  70   3                //  so I did not change/increase the size of "struct data_to_store"
  71   3                //  STORE THE CALIB VOLTAGE IN THE SPI NOR FLASH after every calib, total 4*60=240 byte of data for e
             -ach calib time
  72   3                //if(i%2==0)
  73   3                {
  74   4                  AT25SF041_WriteEnable();
  75   4                  //Wait_ms_SPINOR(50); 
  76   4                  AT25SF041_Write(Byte_Page_Program, *address_to_write,pwm_time/4);                 // SUNLIGHT
  77   4                  Wait_ms_SPINOR(50); 
  78   4                  ++*address_to_write;
  79   4                  
  80   4                  AT25SF041_WriteEnable();
  81   4                  //Wait_ms_SPINOR(50); 
  82   4                  AT25SF041_Write(Byte_Page_Program, *address_to_write,voltage_at_scanned_pos[i]/4);// SOLAR CELL ADC 
             -VOLTAGE  
  83   4                  Wait_ms_SPINOR(50); 
  84   4                  ++*address_to_write;
  85   4                  
  86   4                  AT25SF041_WriteEnable();
  87   4                  //Wait_ms_SPINOR(50); 
  88   4                  AT25SF041_Write(Byte_Page_Program, *address_to_write,*current_position);          // SOLAR CELL Instant P
             -osition when calib
  89   4                  Wait_ms_SPINOR(50); 
  90   4                  ++*address_to_write;  
  91   4                  
  92   4                  AT25SF041_WriteEnable();
  93   4                  //Wait_ms_SPINOR(50); 
  94   4                  AT25SF041_Write(Byte_Page_Program, *address_to_write,(*current_position-(char)*current_position)*100
             -);  // SOLAR CELL Instant Position when calib
  95   4                  Wait_ms_SPINOR(50); 
  96   4                  ++*address_to_write;
  97   4        
  98   4                }
  99   3                
 100   3              }
 101   2              /*else
 102   2              {
 103   2                // go back to JP max position
 104   2                if(i<=29)
 105   2                  Move(calib_step_move*(29-(i-1)),1);//
 106   2                  //*current_position=*current_position+calib_step_move*(29-i);
 107   2                else
 108   2                  Move(calib_step_move*(i-1-29),0);// 
 109   2                
 110   2                *current_position=*current_position+calib_step_move*(29-(i-1));
C51 COMPILER V9.52.0.0   CALIBRATION                                                       05/14/2019 16:10:22 PAGE 3   

 111   2                break;// break FOR LOOP
 112   2              }*/
 113   2              
 114   2              //move cursor to line 1, pos 6
 115   2              //Write_PI4IOE5V96248(&dat);
 116   2              Command(0x08);
 117   2              Command(0x05);
 118   2              
 119   2              WriteData(0x41);//display "A"
 120   2              WriteData(0x44);//display "D"
 121   2              WriteData(0x43);//display "C" 
 122   2              WriteData(0x3A);//display ":" 
 123   2              //LCD_clear();
 124   2              //real_voltage=(float)voltage_at_scanned_pos[i]/1024*5;
 125   2              Display_Pos((float)voltage_at_scanned_pos[i]/1024*5);
 126   2              WriteData(0x56);//display "V" 
 127   2              WriteData(0x10);//display " " 
 128   2              Wait_ms(200);
 129   2              
 130   2              Move(calib_step_move,1);//1: positive direction
 131   2              *current_position=*current_position+0.5;
 132   2              Wait_ms(800);// delay to wait for the electronic load to be stable.
 133   2      
 134   2          }
 135   1          Wait_ms(1000);
 136   1      
 137   1          if(i==81)// make sure that all of the calibration value are scanned with GOOD SUN
 138   1          {
 139   2            max_location=Max_Value(voltage_at_scanned_pos);//max_location in an array [0,...,80]
 140   2            *calib_max_ADC_Value=voltage_at_scanned_pos[max_location];
 141   2      
 142   2            *max_ADC_JP_value=voltage_at_scanned_pos[40];
 143   2          
 144   2            // move to the optimal position in the area of +/-10mm from JP max theorical pos
 145   2            Move(calib_step_move*(81-(float)max_location)+0.8,0);// 0.8 is the offset error
 146   2            *current_position=*current_position-(calib_step_move*(81-(float)max_location)+0.8);
 147   2            Wait_ms(500);
 148   2          }
 149   1      
 150   1      }
 151          
 152          
 153          unsigned int Max_Value(unsigned int *input)
 154          {
 155   1        unsigned int max=0,max_location=40,i;
 156   1        //int i;
 157   1        for(i=0;i<81;i++) //total 81 diff values
 158   1        {
 159   2          max=max>*(input+i)? max:*(input+i);
 160   2          if (max==*(input+i)&& max!=0)
 161   2            max_location=i;
 162   2        }
 163   1        return max_location;// pos in the array
 164   1        
 165   1      }
 166          //input currnt_pos is the JP max theorical position
 167          float calibration(    unsigned char mnths,unsigned char dys,
 168                                unsigned char hurs,unsigned char mns,unsigned char sconds,
 169                                float  *currnt_pos,unsigned int *calib_max_ADC_Val,float *theorical_max_pos,
 170                                unsigned int *max_ADC_JP_value,unsigned long int *NOR_address_to_write)
 171          {
 172   1        float calib_value=0;
C51 COMPILER V9.52.0.0   CALIBRATION                                                       05/14/2019 16:10:22 PAGE 4   

 173   1        unsigned int temporary_calib_max_ADC=0,temp_max_ADC_JP_value=0;//
 174   1        unsigned long int temp_NOR_address_to_write=*NOR_address_to_write;
 175   1        float JP_max_pos=*currnt_pos;
 176   1        *calib_max_ADC_Val=0;
 177   1        *max_ADC_JP_value=0;
 178   1        *theorical_max_pos=0;
 179   1        // if voltage is stable 
 180   1        if(voltage_is_stable())
 181   1        {
 182   2          //  move to JP theorical max position-20
 183   2          Update_position(mnths,dys,hurs,mns,sconds,&JP_max_pos,-20);// off set is Zero means we go to  (first, go
             - to JP max theorical position -20)
 184   2          *theorical_max_pos=JP_max_pos+20;// compensate +20 because of previous line.
 185   2          //  find the real max value in the area of JP +/- 15mm
 186   2          Find_Real_Max(&JP_max_pos,&temporary_calib_max_ADC,&temp_max_ADC_JP_value,&temp_NOR_address_to_write); /
             -/find real max and move to real max position
 187   2          
 188   2          *NOR_address_to_write=temp_NOR_address_to_write;
 189   2          
 190   2          *calib_max_ADC_Val=temporary_calib_max_ADC;
 191   2          *max_ADC_JP_value=temp_max_ADC_JP_value;
 192   2          calib_value=JP_max_pos-*theorical_max_pos;
 193   2          *currnt_pos=JP_max_pos;
 194   2          return calib_value;
 195   2        }
 196   1        else
 197   1          return 0;
 198   1      }
 199          int FindClosestSamedayCalibTime(int *input_calibration_bool_array,int current_time_stamp_position)
 200          {
 201   1        int i;
 202   1        for(i=current_time_stamp_position;i>=0;i--)
 203   1        {
 204   2          if(*(input_calibration_bool_array+i)==1)// find the closest calibrated time stamp
 205   2            return i;// return the position in the array
 206   2          else 
 207   2            return 0;
 208   2        }
 209   1      }
*** WARNING C291 IN LINE 209 OF Calibration.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1942    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     251
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
