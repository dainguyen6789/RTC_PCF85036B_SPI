C51 COMPILER V9.52.0.0   CALIBRATION                                                       02/21/2019 14:00:27 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CALIBRATION
OBJECT MODULE PLACED IN .\Obj\Calibration.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Calibration.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXTE
                    -ND PRINT(.\Lis\Calibration.lst) TABS(2) OBJECT(.\Obj\Calibration.obj)

line level    source

   1          //#include "ADCh.h"
   2          #include "stc15f2k60s2.h"
   3          #include <stdio.h>
   4          #include <stdlib.h>
   5          #include "ADCh.h"
   6          void Wait_ms(int ms);
   7          unsigned int ADC_GetResult(unsigned char ch);
   8          void Move(float  distance, bit direction);
   9          unsigned int Max_Value(unsigned int *input);
  10          void Update_position(unsigned char mnths,unsigned char dys,
  11                               unsigned char hurs,unsigned char mns,unsigned char sconds,
  12                               float  *currnt_pos, float offset_calib);
  13          unsigned int Day_Of_Year(unsigned char months_bcd,unsigned char days_bcd); // this function is used to cou
             -nt the date in a year example: 22 March is the 80th day of the year
  14          void WriteData(unsigned char dat);
  15          void Command(unsigned char dat);//dat=0x0X
  16          void Display_Pos(float sign_dat);
  17          // read adc ch to sense the voltage of the solar panel.     
  18          
  19          int voltage_is_stable(void)
  20          {
  21   1        unsigned int sample_voltage[10];
  22   1        int i,ch=0;
  23   1        for (i=0; i<10;i++)
  24   1        {
  25   2              sample_voltage[i]=ADC_GetResult(ch);
  26   2        }
  27   1        
  28   1        for(i=1;i<=9;i++)
  29   1        {
  30   2              if(abs(sample_voltage[i]-sample_voltage[0])>ADC_Stable_Threshold)
  31   2                return 0;
  32   2        }
  33   1        return 1;
  34   1      }
  35          void  Find_Real_Max(float  *current_position)
  36          {
  37   1          unsigned char ch=0;
  38   1          float calib_step_move=0.5;
  39   1          unsigned int voltage_at_scanned_pos[60],max_location;
  40   1          int i;
  41   1          // move/scan +`
  42   1          for(i=0;i<60;i++)
  43   1          {
  44   2            voltage_at_scanned_pos[i]=0;
  45   2          }
  46   1          for(i=0;i<60;i++)
  47   1          {
  48   2              if(ADC_GetResult(2)>=sunlight_ADC_Threshold)
  49   2              {
  50   3                Move(calib_step_move,1);
  51   3                *current_position=*current_position+0.5;
  52   3                voltage_at_scanned_pos[i]=ADC_GetResult(ch);
  53   3              }
C51 COMPILER V9.52.0.0   CALIBRATION                                                       02/21/2019 14:00:27 PAGE 2   

  54   2              else
  55   2              {
  56   3                // go back to JP max position
  57   3                if(i<=29)
  58   3                  Move(calib_step_move*(29-(i-1)),1);//
  59   3                  //*current_position=*current_position+calib_step_move*(29-i);
  60   3                else
  61   3                  Move(calib_step_move*(i-1-29),0);// 
  62   3                
  63   3                *current_position=*current_position+calib_step_move*(29-(i-1));
  64   3                break;// break FOR LOOP
  65   3              }
  66   2              
  67   2              //move cursor to line 1, pos 6
  68   2              //Write_PI4IOE5V96248(&dat);
  69   2              Command(0x08);
  70   2              Command(0x05);
  71   2              
  72   2              WriteData(0x41);//display "A"
  73   2              WriteData(0x44);//display "D"
  74   2              WriteData(0x43);//display "C" 
  75   2              WriteData(0x3A);//display ":" 
  76   2              //LCD_clear();
  77   2              //real_voltage=(float)voltage_at_scanned_pos[i]/1024*5;
  78   2              Display_Pos((float)voltage_at_scanned_pos[i]/1024*5);
  79   2              WriteData(0x56);//display "V" 
  80   2              WriteData(0x10);//display " " 
  81   2              Wait_ms(1500);
  82   2          }
  83   1        // go back to JP max theorical position
  84   1      /*    Move(10,0);
  85   1          *current_position=*current_position-10; 
  86   1          Wait_ms(500);
  87   1        // move/scan -direction
  88   1        for (i=1;i<=20;i++)
  89   1        {
  90   1      
  91   1            Move(calib_step_move,1);
  92   1            *current_position=*current_position+0.5;
  93   1            voltage_at_scanned_pos[i]=ADC_GetResult(ch);
  94   1            Wait_ms(500);
  95   1        }*/
  96   1          if(i==60)// make sure that all of the calibration value are scanned with GOOD SUN
  97   1          {
  98   2            max_location=Max_Value(voltage_at_scanned_pos);//max_location in an array [0,...,39]
  99   2            // move to the optimal position in the area of +/-10mm from JP max theorical pos
 100   2            Move(calib_step_move*(59-max_location),0);
 101   2            *current_position=*current_position-calib_step_move*(59-max_location);
 102   2            Wait_ms(500);
 103   2          }
 104   1      
 105   1      }
 106          
 107          
 108          unsigned int Max_Value(unsigned int *input)
 109          {
 110   1        unsigned int max=0,max_location=29,i;
 111   1        //int i;
 112   1        for(i=0;i<=59;i++)
 113   1        {
 114   2          max=max>*(input+i)? max:*(input+i);
 115   2          if (max==*(input+i)&& max!=0)
C51 COMPILER V9.52.0.0   CALIBRATION                                                       02/21/2019 14:00:27 PAGE 3   

 116   2            max_location=i;
 117   2        }
 118   1        return max_location;// pos in the array
 119   1        
 120   1      }
 121          //input currnt_pos is the JP max theorical position
 122          float calibration(unsigned char mnths,unsigned char dys,
 123                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 124                               float  *currnt_pos)
 125          {
 126   1        float calib_value=0,theorical_max_pos;
 127   1        float JP_max_pos=*currnt_pos;
 128   1        // if voltage is stable 
 129   1        if(voltage_is_stable())
 130   1        {
 131   2          //  move to JP theorical max position-15
 132   2          Update_position(mnths,dys,hurs,mns,sconds,&JP_max_pos,-15);// off set is Zero means we go to  (first, go
             - to JP max theorical position -5)
 133   2          theorical_max_pos=JP_max_pos+15;// compensate +15 because of previous line.
 134   2          //  find the real max value in the area of JP +/- 15mm
 135   2          Find_Real_Max(&JP_max_pos); //find real max and move to real max position
 136   2          calib_value=JP_max_pos-theorical_max_pos;
 137   2          *currnt_pos=JP_max_pos;
 138   2          return calib_value;
 139   2        }
 140   1        else
 141   1          return 0;
 142   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1260    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     180
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
