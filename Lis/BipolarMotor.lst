C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/23/2018 17:34:54 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXT
                    -END PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          #include "SunPos.h"
   6          //#include "PCF85963BTL.h"
   7          void Delay_ms(unsigned int ms);
   8          int Day_Of_Year(unsigned char months,unsigned char days);
   9          unsigned char BCDtoDec1(char bcd);
  10          float  degree;
  11          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  12                      float  a21, float  a22, float  a23, float  a24,
  13                      float  a31, float  a32, float  a33, float  a34,
  14                      float  a41, float  a42, float  a43, float  a44 );
  15           float  findDet3x3( 
  16                      float  a11, float  a12, float  a13, 
  17                      float  a21, float  a22, float  a23,
  18                      float  a31, float  a32, float  a33 );           
  19          float
  20          cubic_interpolate (float *p1, float *p2, float *p3, float *p4, float x);
  21          
  22          unsigned char BCDtoDec1(unsigned char bcd)
  23          {
  24   1        unsigned char hi,lo;
  25   1        hi=bcd>>4;
  26   1        lo=bcd&0x0F;
  27   1        return hi*10+lo;
  28   1      }
  29          
  30          
  31          
  32          
  33          
  34          void Step_move(unsigned int step, bit dir)
  35          {
  36   1            unsigned int i=0;
  37   1            if(dir)
  38   1              P4 |=(1<<2);// set bit P4.2
  39   1            else
  40   1              P4 &=~(1<<2);// clear bit P4.2
  41   1            
  42   1            for( i=0;i<step;i++)
  43   1            {
  44   2                P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
  45   2                Wait_ms(2);
  46   2                P4 &= ~(1<<1);
  47   2                Wait_ms(2);
  48   2            }
  49   1      }
  50          
  51          void Move(float  distance, bit direction)
  52          {
  53   1          unsigned int step;
  54   1          step= (unsigned int)(distance*337.5/(3.14159));
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/23/2018 17:34:54 PAGE 2   

  55   1          Step_move(step,direction);
  56   1      }
  57          //=====================================================
  58          //We need 4 points for cubic interpolation, p1[x],p1[y],..,p4[x],p4[y]
  59           float  findDet3x3( 
  60                      float  a11, float  a12, float  a13, 
  61                      float  a21, float  a22, float  a23,
  62                      float  a31, float  a32, float  a33 )
  63          {
  64   1          return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
  65   1                  a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
  66   1      }
  67          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  68                      float  a21, float  a22, float  a23, float  a24,
  69                      float  a31, float  a32, float  a33, float  a34,
  70                      float  a41, float  a42, float  a43, float  a44 )
  71          {
  72   1        
  73   1          //return a11*(float)findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44);
  74   1          //return (float)findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44);
  75   1          //return (float)findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44);
  76   1          //return (float)findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43);
  77   1        //  return a21;
  78   1          return( a11*findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44) -
  79   1                  a12*findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44) +
  80   1                  a13*findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44) -
  81   1                  a14*findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43));
  82   1      }
  83              
  84          //===================================================== 
  85          
  86           
  87          //===================================================== 
  88          float  linear_interpolate(struct point p1,struct point p2, float  x)
  89          {
  90   1        float  fx;
  91   1        
  92   1        fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
  93   1        
  94   1        return fx;
  95   1      }
  96          
  97          //  2nd order interpolate: 
  98          //  input 3 points p1,p2,p3 and desired x value
  99          //  output: f(x)
 100          float second_order_interpolate(struct point p1,struct point p2, struct point p3, float  x)
 101          {
 102   1        //float a,b,c;// fx=ax^2+bx+c
 103   1        float det,det_x,det_y,det_z,fx;
 104   1        
 105   1        det=findDet3x3(pow(p1.x,2) ,p1.x ,1 ,  pow(p2.x,2) ,p2.x ,1 ,   pow(p3.x,2) ,p3.x ,1 );
 106   1        
 107   1        det_x=findDet3x3(p1.y ,p1.x ,1 ,  p2.y ,p2.x ,1 ,   p3.y ,p3.x ,1 );
 108   1        
 109   1        det_y=findDet3x3(pow(p1.x,2) ,p1.y ,1 ,  pow(p2.x,2) ,p2.y ,1 ,   pow(p3.x,2) ,p3.y ,1 );
 110   1        
 111   1        det_z=findDet3x3(pow(p1.x,2) ,p1.x ,p1.y ,  pow(p2.x,2) ,p2.x ,p2.y ,   pow(p3.x,2) ,p3.x ,p3.y );
 112   1        if(det!=0)
 113   1          fx=det_x/det*pow(x,2)+det_y/det*x+det_z/det;
 114   1        else
 115   1          fx=0;
 116   1        return fx;
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/23/2018 17:34:54 PAGE 3   

 117   1      }
 118          
 119          void Update_position(unsigned char mnths,unsigned char dys,
 120                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 121                               float  *currnt_pos)
 122          {
 123   1        unsigned int date,i,yy;
 124   1        float  desired_distance,distance=0,JP_pos;
 125   1        float  pos_interpolate_12_17h[num_of_time_stamp],current_time;
 126   1        float declination;
 127   1        struct point p1,p2,p3;
 128   1        struct cTime time;
 129   1        struct cLocation location;
 130   1        struct cSunCoordinates *sunCoord;
 131   1        hurs=hurs-0x01;// change to sun time
 132   1        dys=dys+0x04;// shift 4 days because of Jean Phillip
 133   1        time.iYear=2018;
 134   1        time.iMonth=BCDtoDec1(mnths);
 135   1        time.iDay=BCDtoDec1(dys);
 136   1        time.dHours=BCDtoDec1(hurs);
 137   1        time.dMinutes=BCDtoDec1(mns);
 138   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 139   1      
 140   1        
 141   1        desired_distance=*currnt_pos;
 142   1        date=Day_Of_Year(mnths,dys);
 143   1        //date=237;
 144   1        declination=sunpos(time,location,&sunCoord)*180/pi;
*** WARNING C182 IN LINE 144 OF BipolarMotor.c: pointer to different objects
 145   1        if (BCDtoDec1(sconds&0x7f)%3==0)
 146   1        {
 147   2          current_time=(float) BCDtoDec1(hurs)+(float)BCDtoDec1(mns)/60;//+(float)BCDtoDec1(sconds&0x7f)/3600;
 148   2      
 149   2        // interpolate for day
 150   2          for (i=0;i<num_of_day_stamp;i++)
 151   2          {
 152   3            if (declination<=date_declination_mapping[i] && declination>=date_declination_mapping[i+1])
 153   3            {
 154   4              for (yy=0;yy<num_of_time_stamp;yy++)
 155   4              {
 156   5                p1.x=date_declination_mapping[i];
 157   5                p2.x=date_declination_mapping[i+1];
 158   5                
 159   5                p1.y=RX_pos[yy][i];
 160   5                p2.y=RX_pos[yy][i+1];
 161   5                if (i>0 && i<8)
 162   5                {
 163   6                  if(   (declination-date_declination_mapping[i+1]) > (date_declination_mapping[i]-declination)   )
 164   6                  {
 165   7                    p3.x=date_declination_mapping[i-1];
 166   7                    p3.y=RX_pos[yy][i-1];;
 167   7                  }
 168   6                  else
 169   6                  {
 170   7                    p3.x=date_declination_mapping[i+2];
 171   7                    p3.y=RX_pos[yy][i+2];;
 172   7                  }
 173   6                }
 174   5                if(i==0)
 175   5                {
 176   6                    p3.x=date_declination_mapping[i+2];
 177   6                    p3.y=RX_pos[yy][i+2];;
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/23/2018 17:34:54 PAGE 4   

 178   6                }
 179   5                if(i==8)
 180   5                {
 181   6                    p3.x=date_declination_mapping[i-1];
 182   6                    p3.y=RX_pos[yy][i-1];;
 183   6                }
 184   5                pos_interpolate_12_17h[yy]=second_order_interpolate(p1,p2,p3,declination);
 185   5              }
 186   4              //break;
 187   4            }
 188   3          }
 189   2      
 190   2          // interpolate for hour
 191   2          for(i=0;i<num_of_time_stamp;i++)
 192   2          {
 193   3            if(current_time>=Time_stamp_PM[i]&&current_time<=Time_stamp_PM[i+1])
 194   3            {
 195   4              p1.x=Time_stamp_PM[i];
 196   4              p2.x=Time_stamp_PM[i+1];
 197   4              
 198   4              p1.y=pos_interpolate_12_17h[i];
 199   4              p2.y=pos_interpolate_12_17h[i+1];
 200   4              if(i==0)// i==0
 201   4              {
 202   5                p3.x=Time_stamp_PM[i+2];
 203   5                p3.y=pos_interpolate_12_17h[i+2];
 204   5                
 205   5              }
 206   4              else if(i==(num_of_time_stamp-1))
 207   4              {
 208   5                p3.x=Time_stamp_PM[i-1];
 209   5                p3.y=pos_interpolate_12_17h[i-1];
 210   5              }
 211   4              else
 212   4              {
 213   5                if(   (current_time-Time_stamp_PM[i])>=(Time_stamp_PM[i+1]-current_time)   )
 214   5                {
 215   6                    p3.x=Time_stamp_PM[i+2];
 216   6                    p3.y=pos_interpolate_12_17h[i+2];
 217   6                }
 218   5                else
 219   5                {
 220   6                    p3.x=Time_stamp_PM[i-1];
 221   6                    p3.y=pos_interpolate_12_17h[i-1];
 222   6                }
 223   5              }
 224   4              
 225   4              JP_pos=second_order_interpolate(p2,p1,p3,current_time);
 226   4              //break;
 227   4              
 228   4            }
 229   3            
 230   3          }
 231   2          
 232   2        desired_distance=179+2*JP_pos;
 233   2          
 234   2        distance=desired_distance-*currnt_pos;
 235   2        
 236   2        if(distance>0)
 237   2          Move(distance,1);
 238   2        else
 239   2          Move(-distance,0);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/23/2018 17:34:54 PAGE 5   

 240   2      }
 241   1        *currnt_pos=desired_distance;
 242   1        return;
 243   1      
 244   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4820    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    968     347
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
