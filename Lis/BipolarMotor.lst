C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 09:59:25 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXT
                    -END PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          #include "SunPos.h"
   6          //#include "PCF85963BTL.h"
   7          void Delay_ms(unsigned int ms);
   8          int Day_Of_Year(unsigned char months,unsigned char days);
   9          unsigned char BCDtoDec1(char bcd);
  10          float  degree;
  11          unsigned char previous_move_time=0;
  12          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  13                      float  a21, float  a22, float  a23, float  a24,
  14                      float  a31, float  a32, float  a33, float  a34,
  15                      float  a41, float  a42, float  a43, float  a44 );
  16           float  findDet3x3( 
  17                      float  a11, float  a12, float  a13, 
  18                      float  a21, float  a22, float  a23,
  19                      float  a31, float  a32, float  a33 );           
  20          float
  21          cubic_interpolate (float *p1, float *p2, float *p3, float *p4, float x);
  22          
  23          unsigned char BCDtoDec1(unsigned char bcd)
  24          {
  25   1        unsigned char hi,lo;
  26   1        hi=bcd>>4;
  27   1        lo=bcd&0x0F;
  28   1        return hi*10+lo;
  29   1      }
  30          
  31          
  32          
  33          
  34          
  35          void Step_move(unsigned int step, bit dir)
  36          {
  37   1            unsigned int i=0;
  38   1            if(dir)
  39   1              P4 |=(1<<2);// set bit P4.2
  40   1            else
  41   1              P4 &=~(1<<2);// clear bit P4.2
  42   1            
  43   1            for( i=0;i<step;i++)
  44   1            {
  45   2                P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
  46   2                Wait_ms(2);
  47   2                P4 &= ~(1<<1);
  48   2                Wait_ms(2);
  49   2            }
  50   1      }
  51          /*
  52          
  53          // P4.5 direction; P4.3 pulse
  54          void Step_move_2ndMotor(unsigned int step, bit dir)
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 09:59:25 PAGE 2   

  55          {
  56                unsigned int i=0;
  57                if(dir)
  58                  P4 |=(1<<=5);// set bit P4.5
  59                else
  60                  P4 &=~(1<<5);// clear bit P4.5
  61                
  62                for( i=0;i<step;i++)
  63                {
  64                    P4 |=1<<3;// P43=1 // moving distance (mm)=pi^2*step*4/675
  65                    Wait_ms(2);
  66                    P4 &= ~(1<<3);
  67                    Wait_ms(2);
  68                }
  69          }
  70          
  71          void Move_2ndMotor(float  distance, bit direction)
  72          {
  73              unsigned int step;
  74              step= (unsigned int)(distance*337.5/(3.14159));
  75              Step_move_2ndMotor(step,direction);
  76          }
  77          */
  78          void Move(float  distance, bit direction)
  79          {
  80   1          unsigned int step;
  81   1          step= (unsigned int)(distance*337.5/(3.14159));
  82   1          Step_move(step,direction);
  83   1      }
  84          //=====================================================
  85          //We need 4 points for cubic interpolation, p1[x],p1[y],..,p4[x],p4[y]
  86           float  findDet3x3( 
  87                      float  a11, float  a12, float  a13, 
  88                      float  a21, float  a22, float  a23,
  89                      float  a31, float  a32, float  a33 )
  90          {
  91   1          return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
  92   1                  a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
  93   1      }
  94          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  95                      float  a21, float  a22, float  a23, float  a24,
  96                      float  a31, float  a32, float  a33, float  a34,
  97                      float  a41, float  a42, float  a43, float  a44 )
  98          {
  99   1        
 100   1          //return a11*(float)findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44);
 101   1          //return (float)findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44);
 102   1          //return (float)findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44);
 103   1          //return (float)findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43);
 104   1        //  return a21;
 105   1          return( a11*findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44) -
 106   1                  a12*findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44) +
 107   1                  a13*findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44) -
 108   1                  a14*findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43));
 109   1      }
 110              
 111          //===================================================== 
 112          
 113           
 114          //===================================================== 
 115          float  linear_interpolate(struct point p1,struct point p2, float  x)
 116          {
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 09:59:25 PAGE 3   

 117   1        float  fx;
 118   1        
 119   1        fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
 120   1        
 121   1        return fx;
 122   1      }
 123          
 124          
 125          
 126          void Update_position(unsigned char mnths,unsigned char dys,
 127                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 128                               float  *currnt_pos, float offset_calib)
 129          {
 130   1        unsigned int date,i=0,yy=0;
 131   1        
 132   1        float  desired_distance=0,distance=0,JP_pos=0;
 133   1        float  pos_interpolate_azimuth[num_of_azimuth_stamp],current_local_sun_time,azimuth, elevation,time_offse
             -t,UTC_time=-5;
 134   1        float declination;
 135   1        struct point p1,p2;
 136   1        struct cTime time;
 137   1        struct cLocation location;
 138   1        struct cSunCoordinates *sunCoord;
 139   1        //hurs=hurs-1;// change to sun time
 140   1        //dys=dys+4;
 141   1        location.dLongitude=-73.6495;
 142   1        location.dLatitude=45.478889;
 143   1        time.iYear=2018;
 144   1        time.iMonth=BCDtoDec1(mnths);
 145   1        time.iDay=BCDtoDec1(dys);
 146   1        time.dHours=BCDtoDec1(hurs);
 147   1        time.dMinutes=BCDtoDec1(mns);
 148   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 149   1      
 150   1        
 151   1        desired_distance=*currnt_pos;
 152   1        
 153   1        //date=Day_Of_Year(mnths,dys)+4;
 154   1        //date=237;
 155   1        declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
*** WARNING C182 IN LINE 155 OF BipolarMotor.c: pointer to different objects
 156   1        time_offset=1/60*(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(time.iDay-81)/365)*pi/180)    -   
             - 7.53*cos((360*(time.iDay-81)/365)*pi/180)    -   1.5*sin((360*(time.iDay-81)/365)*pi/180));
 157   1        current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=su
             -n time= clock time -1
 158   1        //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 159   1        elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 160   1                  cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
             -          );
 161   1        azimuth=180+(180/pi)*asin(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin
             -((90-elevation)*pi/180)          );// JP calculation
 162   1        //azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((
             -90-elevation)*pi/180)          );// JP calculation
 163   1      
 164   1        
 165   1        //if (current_local_sun_time>12)
 166   1        //  azimuth=360-azimuth;
 167   1        
 168   1        if(BCDtoDec1(sconds&0x7f)%2==0)
 169   1        {
 170   2          // interpolate for azimuth
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 09:59:25 PAGE 4   

 171   2          for (i=0;i<num_of_azimuth_stamp;i++)
 172   2          {
 173   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 174   3            {
 175   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 176   4              {
 177   5                p1.x=date_azimuth_mapping[i];
 178   5                p2.x=date_azimuth_mapping[i+1];
 179   5                
 180   5                p1.y=RX_pos[yy][i];
 181   5                p2.y=RX_pos[yy][i+1];
 182   5                
 183   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 184   5              }
 185   4              //break;
 186   4            }
 187   3          }
 188   2      
 189   2          // interpolate for elevation
 190   2          for(i=0;i<num_of_elevation_stamp;i++)
 191   2          {
 192   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 193   3            {
 194   4              p1.x=elevation_stamp[i];
 195   4              p2.x=elevation_stamp[i+1];
 196   4              
 197   4              p1.y=pos_interpolate_azimuth[i];
 198   4              p2.y=pos_interpolate_azimuth[i+1];
 199   4              
 200   4              JP_pos=linear_interpolate(p1,p2,elevation);
 201   4              //break;
 202   4              
 203   4            }
 204   3            
 205   3          }
 206   2          
 207   2          desired_distance=27+2*JP_pos +offset_calib;
 208   2          
 209   2          distance=desired_distance-*currnt_pos;
 210   2          if(abs(distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is more t
             -han 0.5mm OR >30s
 211   2          {
 212   3            if(distance>0)
 213   3              Move(distance,1);
 214   3            else if (distance<0)
 215   3              Move(-distance,0);
 216   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 217   3            *currnt_pos=desired_distance;
 218   3          }
 219   2        }
 220   1        return;
 221   1      
 222   1      }
*** WARNING C280 IN LINE 130 OF BipolarMotor.c: 'date': unreferenced local variable
 223          
 224          
 225          
 226          
 227          void Update_angle(unsigned char mnths,unsigned char dys,
 228                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 229                               float  *currnt_angle, float offset_calib)
 230          {
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 09:59:25 PAGE 5   

 231   1        unsigned int date,i=0,yy=0;
 232   1        
 233   1        float  desired_distance=0,distance=0,JP_pos=0;
 234   1        float  angle_interpolate_azimuth[num_of_azimuth_stamp],current_local_sun_time,azimuth, elevation,time_off
             -set,UTC_time=-5;
 235   1        float declination;
 236   1        struct point p1,p2;
 237   1        struct cTime time;
 238   1        struct cLocation location;
 239   1        struct cSunCoordinates *sunCoord;
 240   1        //hurs=hurs-1;// change to sun time
 241   1        //dys=dys+4;
 242   1        location.dLongitude=-73.6495;
 243   1        location.dLatitude=45.478889;
 244   1        time.iYear=2018;
 245   1        time.iMonth=BCDtoDec1(mnths);
 246   1        time.iDay=BCDtoDec1(dys);
 247   1        time.dHours=BCDtoDec1(hurs);
 248   1        time.dMinutes=BCDtoDec1(mns);
 249   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 250   1      
 251   1        
 252   1        desired_distance=*currnt_angle;
 253   1        
 254   1        //date=Day_Of_Year(mnths,dys)+4;
 255   1        //date=237;
 256   1        declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
*** WARNING C182 IN LINE 256 OF BipolarMotor.c: pointer to different objects
 257   1        time_offset=1/60*(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(time.iDay-81)/365)*pi/180)    -   
             - 7.53*cos((360*(time.iDay-81)/365)*pi/180)    -   1.5*sin((360*(time.iDay-81)/365)*pi/180));
 258   1        current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=su
             -n time= clock time -1
 259   1        //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 260   1        elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 261   1                  cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
             -          );
 262   1        azimuth=180+(180/pi)*asin(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin
             -((90-elevation)*pi/180)          );// JP calculation
 263   1        //azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((
             -90-elevation)*pi/180)          );// JP calculation
 264   1      
 265   1        
 266   1        //if (current_local_sun_time>12)
 267   1        //  azimuth=360-azimuth;
 268   1        
 269   1        if(BCDtoDec1(sconds&0x7f)%2==0)
 270   1        {
 271   2          // interpolate for azimuth
 272   2          for (i=0;i<num_of_azimuth_stamp;i++)
 273   2          {
 274   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 275   3            {
 276   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 277   4              {
 278   5                p1.x=date_azimuth_mapping[i];
 279   5                p2.x=date_azimuth_mapping[i+1];
 280   5                
 281   5                p1.y=RX_angle[yy][i];
 282   5                p2.y=RX_angle[yy][i+1];
 283   5                
 284   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 09:59:25 PAGE 6   

 285   5              }
 286   4              //break;
 287   4            }
 288   3          }
 289   2      
 290   2          // interpolate for elevation
 291   2          for(i=0;i<num_of_elevation_stamp;i++)
 292   2          {
 293   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 294   3            {
 295   4              p1.x=elevation_stamp[i];
 296   4              p2.x=elevation_stamp[i+1];
 297   4              
 298   4              p1.y=angle_interpolate_azimuth[i];
 299   4              p2.y=angle_interpolate_azimuth[i+1];
 300   4              
 301   4              JP_pos=linear_interpolate(p1,p2,elevation);
 302   4              //break;
 303   4              
 304   4            }
 305   3            
 306   3          }
 307   2          
 308   2          desired_distance=27+2*JP_pos +offset_calib;
 309   2          
 310   2          distance=desired_distance-*currnt_angle;
 311   2          if(abs(distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is more t
             -han 0.5mm OR >30s
 312   2          {
 313   3            if(distance>0)
 314   3              Move(distance,1);
 315   3            else if (distance<0)
 316   3              Move(-distance,0);
 317   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 318   3            *currnt_angle=desired_distance;
 319   3          }
 320   2        }
 321   1        return;
 322   1      
 323   1      }
*** WARNING C280 IN LINE 231 OF BipolarMotor.c: 'date': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5549    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    949     406
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
