C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 17:03:23 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXT
                    -END PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          //#include "PCF85963BTL.h"
   6          void Delay_ms(unsigned int ms);
   7          int Day_Of_Year(unsigned char months,unsigned char days);
   8          unsigned char BCDtoDec1(char bcd);
   9          float degree;
  10          
  11          unsigned char BCDtoDec1(unsigned char bcd)
  12          {
  13   1        unsigned char hi,lo;
  14   1        hi=bcd>>4;
  15   1        lo=bcd&0x0F;
  16   1        return hi*10+lo;
  17   1      }
  18          
  19          
  20          
  21          
  22          
  23          void Step_move(unsigned int step, bit dir)
  24          {
  25   1            unsigned int i=0;
  26   1            if(dir)
  27   1              P4 |=(1<<2);// set bit P4.2
  28   1            else
  29   1              P4 &=~(1<<2);// clear bit P4.2
  30   1            
  31   1            for( i=0;i<step;i++)
  32   1            {
  33   2                P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
  34   2                Wait_ms(2);
  35   2                P4 &= ~(1<<1);
  36   2                Wait_ms(2);
  37   2            }
  38   1      }
  39          
  40          void Move(float distance, bit direction)
  41          {
  42   1          unsigned int step;
  43   1          step= (unsigned int)(distance*337.5/(3.14159));
  44   1          Step_move(step,direction);
  45   1      }
  46          
  47          float linear_interpolate(float x1,float x2,float y1,float y2, float x)
  48          {
  49   1        float a,b;
  50   1        a=(y1-y2)/(x1-x2);
  51   1        b=y1-a*x1;
  52   1        
  53   1        return a*x+b;
  54   1      }
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 17:03:23 PAGE 2   

  55          
  56          
  57          void Update_position(unsigned char mnths,unsigned char dys,unsigned char hurs,unsigned char mns,unsigned c
             -har sconds,float *currnt_pos)
  58          {
  59   1        unsigned int date,i,yy;
  60   1        float desired_distance,distance=0;
  61   1        float pos_interpolate_12_17h[21][1];
  62   1        /*hurs=0x12;
  63   1        mns=0x30;*/
  64   1        //sconds=0x15;
  65   1        desired_distance=*currnt_pos;
  66   1        date=Day_Of_Year(mnths,dys);
  67   1        
  68   1        if(date>=79 && date<=171)
  69   1        {
  70   2          // interpolate for day
  71   2          for (i=0;i<=8;i++)
  72   2          {
  73   3            if (date>= date_stamp_79_171[i] && date<= date_stamp_79_171[i+1])
  74   3            {
  75   4              for (yy=0;yy<21;yy++)
  76   4              {
  77   5                pos_interpolate_12_17h[yy][0]=linear_interpolate(date_stamp_79_171[i],date_stamp_79_171[i+1]
  78   5                ,exact_rx_pos_simulation[yy][i],exact_rx_pos_simulation[yy][i+1],date);
  79   5              }
  80   4            }
  81   3          }
  82   2          //interpolate for hour
  83   2          for(i=0;i<num_of_time_stamp;i++)// 
  84   2          {
  85   3            if (BCDtoDec1(hurs)==Time_stamp_PM[i][0] && BCDtoDec1(mns)== Time_stamp_PM[i][1] && BCDtoDec1(sconds&0x
             -7f)==Time_stamp_PM[i][2])// check if current time match the time stamp in the table
  86   3            {     
  87   4              desired_distance=pos_interpolate_12_17h[i][0];//18July2018 is stored in the 1st column
  88   4            }
  89   3              
  90   3              //desired_distance=receiver_pos[0][4];;
  91   3              //distance=11;
  92   3              distance=desired_distance-*currnt_pos;
  93   3              *currnt_pos=desired_distance;// change to sync with step movement
  94   3              if(distance>0)
  95   3              {
  96   4                Move(distance,1);// counter clock wise
  97   4              }
  98   3              else if(distance<0)
  99   3              {
 100   4                Move(-distance,0);// clock wise
 101   4              }
 102   3              else
 103   3              {
 104   4              } 
 105   3              
 106   3            
 107   3            if ((i+1)<num_of_time_stamp && ((BCDtoDec1(hurs)*60+BCDtoDec1(mns))<=(Time_stamp_PM[i+1][0]*60+Time_sta
             -mp_PM[i+1][1])) && ((BCDtoDec1(hurs)*60+BCDtoDec1(mns))>=(Time_stamp_PM[i][0]*60+Time_stamp_PM[i][1])) && BCDtoDec1(scon
             -ds&0x7f)%30==0)// update every 30 sec
 108   3            {
 109   4      
 110   4              desired_distance=linear_interpolate(Time_stamp_PM[i][0]+Time_stamp_PM[i][1]/60,
 111   4                                                  Time_stamp_PM[i+1][0]+Time_stamp_PM[i+1][1]/60,pos_interpolate_12_17h[i][0],
 112   4                                                  pos_interpolate_12_17h[i+1][0],(float)BCDtoDec1(hurs)+(float)BCDtoDec1(mns)/60+(floa
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 17:03:23 PAGE 3   

             -t)BCDtoDec1(sconds&0x7f)/3600);
 113   4              distance=desired_distance-*currnt_pos;
 114   4              *currnt_pos=desired_distance;// change to sync with step movement
 115   4              if(distance>0)
 116   4              {
 117   5                Move(distance,1);// counter clock wise
 118   5              }
 119   4              else if(distance<0)
 120   4              {
 121   5                Move(-distance,0);// clock wise
 122   5              }
 123   4              else
 124   4              {
 125   5              } 
 126   4              
 127   4              
 128   4            }
 129   3            
 130   3          }
 131   2        }
 132   1        // interpolate for hour
 133   1      
 134   1      }
 135          
 136          float pos_day_171(float time){
 137   1        return 0.3224*pow(time,4) - 16.883*pow(time,3) + 336.15*pow(time,2) - 3004.8*time + 10281;
 138   1      }
 139          float pos_day_152_190(float time){
 140   1        return 0.3957*pow(time,4) - 20.914*pow(time,3) + 418.74*pow(time,2) - 3752.6*time + 12796;
 141   1      }
 142          
 143          float pos_day_139_203(float time){
 144   1       return 0.4751*pow(time,4) - 25.31*pow(time,3) + 509.39*pow(time,2) - 4578.4*time + 15589;
 145   1      }
 146          
 147          float pos_day_121_221(float time){
 148   1        return 0.6567*pow(time,4) - 35.589*pow(time,3) + 725.58*pow(time,2)  - 6585.1*time + 22505;
 149   1      } 
 150          
 151          float pos_day_113_229(float time){
 152   1        return 0.6698*pow(time,4)- 36.416*pow(time,3) + 744.21*pow(time,2)  - 6765.5*time + 23132;
 153   1      }
 154          float pos_day_106_236(float time){
 155   1        return 0.6886*pow(time,4) - 37.644*pow(time,3) + 772.66*pow(time,2)  - 7048.9*time + 24153;
 156   1      }
 157          float pos_day_94_248(float time){
 158   1        return 0.4628*pow(time,4) - 25.404*pow(time,3) + 523.11*pow(time,2)  - 4784.2*time + 16416;
 159   1      }
 160          float pos_day_87_255(float time){
 161   1        return 0.288*pow(time,4) - 15.904*pow(time,3) + 329.15*pow(time,2)  - 3023.8*time+ 10412;
 162   1      }
 163          //
 164          /*
 165            for(i=0;i<13;i++)
 166            {
 167              if (BCDtoDec1(hurs)<=Time_stamp_PM[i+1][0] && BCDtoDec1(hurs)>=Time_stamp_PM[i][0] && BCDtoDec1(mns)>= T
             -ime_stamp_PM[i][1] && BCDtoDec1(mns)<= Time_stamp_PM[i+1][1] && BCDtoDec1(mns)%5==0)
 168              {
 169                desired_distance=(receiver_pos[i+1][0]-receiver_pos[i][0])/(Time_stamp_PM[i+1][0]*60+Time_stamp_PM[i+1]
             -[1]-Time_stamp_PM[i][0]*60-Time_stamp_PM[i][1])*(BCDtoDec1(hurs)*60+BCDtoDec1(mns)-Time_stamp_PM[i][0]*60-Time_stamp_PM[
             -i][1])+receiver_pos[i][0];
 170              }
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 17:03:23 PAGE 4   

 171            }
 172          */
 173          
 174          //int Day_Of_Year(unsigned char months,unsigned char days)*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4134    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1037     174
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
