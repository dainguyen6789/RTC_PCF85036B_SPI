C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 10:35:36 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXT
                    -END PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
*** ERROR C242 IN LINE 50 OF .\Application\Header\Receiver_Position_Data.h: 'scalar': too many initializers
*** ERROR C141 IN LINE 66 OF .\Application\Header\Receiver_Position_Data.h: syntax error near 'unsigned'
*** ERROR C279 IN LINE 66 OF .\Application\Header\Receiver_Position_Data.h: 'Time_stamp_PM': multiple initialization
*** ERROR C231 IN LINE 66 OF .\Application\Header\Receiver_Position_Data.h: 'Time_stamp_PM': redefinition
   4          #include "math.h"
*** ERROR C141 IN LINE 14 OF C:\Keil_v5\C51\Inc\math.h: syntax error near 'extern'
   5          //#include "PCF85963BTL.h"
   6          void Delay_ms(unsigned int ms);
   7          int Day_Of_Year(unsigned char months,unsigned char days);
   8          unsigned char BCDtoDec1(char bcd);
   9          float degree;
  10          
  11          unsigned char BCDtoDec1(unsigned char bcd)
  12          {
  13   1        unsigned char hi,lo;
  14   1        hi=bcd>>4;
  15   1        lo=bcd&0x0F;
  16   1        return hi*10+lo;
  17   1      }
  18          
  19          
  20          
  21          
  22          
  23          void Step_move(unsigned int step, bit dir)
  24          {
  25   1            unsigned int i=0;
  26   1            if(dir)
  27   1              P4 |=(1<<2);// set bit P4.2
  28   1            else
  29   1              P4 &=~(1<<2);// clear bit P4.2
  30   1            
  31   1            for( i=0;i<step;i++)
  32   1            {
  33   2                P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
  34   2                Wait_ms(2);
  35   2                P4 &= ~(1<<1);
  36   2                Wait_ms(2);
  37   2            }
  38   1      }
  39          
  40          void Move(float distance, bit direction)
  41          {
  42   1          unsigned int step;
  43   1          step= (unsigned int)(distance*337.5/(3.14159));
  44   1          Step_move(step,direction);
  45   1      }
  46          
  47          float linear_interpolate(float x1,float x2,float y1,float y2, float x)
  48          {
  49   1        float a,b;
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 10:35:36 PAGE 2   

  50   1        a=(y1-y2)/(x1-x2);
  51   1        b=y1-a*x1;
  52   1        
  53   1        return a*x+b;
  54   1      }
  55          
  56          
  57          void Update_position(unsigned char mnths,unsigned char dys,unsigned char hurs,unsigned char mns,unsigned c
             -har sconds,float *currnt_pos)
  58          {
  59   1        unsigned int date,i,yy;
  60   1        float desired_distance,distance=0;
  61   1        float pos_interpolate_12_17h[11][1];
  62   1        /*hurs=0x12;
  63   1        mns=0x30;*/
  64   1        //sconds=0x15;
  65   1        desired_distance=*currnt_pos;
  66   1        date=Day_Of_Year(mnths,dys);
  67   1        // interpolate for day
  68   1        for (i=0;i<=8;i++)
  69   1        {
  70   2          if (date> date_stamp[i] && date< date_stamp[i+1])
  71   2          {
  72   3            for (yy=0;yy<=11;yy++)
  73   3            {
  74   4              pos_interpolate_12_17h[yy][0]=linear_interpolate(date_stamp[i],date_stamp[i+1],exact_rx_pos_simulation
             -[yy][i],exact_rx_pos_simulation[yy][i+1],date);
  75   4            }
  76   3          }
  77   2        }
  78   1        
  79   1        //date=80;
  80   1      /*  for(i=0;i<num_of_time_stamp;i++)// 13 diff values of time stamp
  81   1        {
  82   1          if (BCDtoDec1(hurs)==Time_stamp_PM[i][0] && BCDtoDec1(mns)== Time_stamp_PM[i][1] && BCDtoDec1(sconds&0x7
             -f)==Time_stamp_PM[i][2])// check if current time match the time stamp in the table
  83   1          {     
  84   1            switch(date)
  85   1            {
  86   1              case 212://29July2018
  87   1                desired_distance=receiver_pos[i][0];//18July2018 is stored in the 1st column
  88   1                break; 
  89   1              case 80:
  90   1                desired_distance=receiver_pos[i][1];
  91   1                break;
  92   1              case 81:
  93   1                desired_distance=receiver_pos[i][2];
  94   1                break;
  95   1              case 82:
  96   1                desired_distance=receiver_pos[i][3];
  97   1                break;
  98   1              case 83:
  99   1                desired_distance=receiver_pos[i][4];
 100   1                break;
 101   1              default:
 102   1                break;
 103   1            }
 104   1            
 105   1            //desired_distance=receiver_pos[0][4];;
 106   1            //distance=11;
 107   1            distance=desired_distance-*currnt_pos;
 108   1            *currnt_pos=desired_distance;// change to sync with step movement
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 10:35:36 PAGE 3   

 109   1            if(distance>0)
 110   1            {
 111   1              Move(distance,1);// counter clock wise
 112   1            }
 113   1            else if(distance<0)
 114   1            {
 115   1              Move(-distance,0);// clock wise
 116   1            }
 117   1            else
 118   1            {
 119   1            } 
 120   1            
 121   1            break;
 122   1          }
 123   1          if ((i+1)<num_of_time_stamp && ((BCDtoDec1(hurs)*60+BCDtoDec1(mns))<=(Time_stamp_PM[i+1][0]*60+Time_stam
             -p_PM[i+1][1])) && ((BCDtoDec1(hurs)*60+BCDtoDec1(mns))>=(Time_stamp_PM[i][0]*60+Time_stamp_PM[i][1])) && BCDtoDec1(mns)%
             -2==0)// update every 2 mins
 124   1          {
 125   1            switch(date)
 126   1            {
 127   1              case 212://30July2018
 128   1                desired_distance=(receiver_pos[i+1][0]-receiver_pos[i][0])/(Time_stamp_PM[i+1][0]*60+Time_stamp_PM[i+
             -1][1]
 129   1                                  -Time_stamp_PM[i][0]*60-Time_stamp_PM[i][1])
 130   1                                  *(BCDtoDec1(hurs)*60+BCDtoDec1(mns)-Time_stamp_PM[i][0]*60-Time_stamp_PM[i][1])
 131   1                                  +receiver_pos[i][0];// desired_pos=(pos_end-pos_start)/(time_end-time_start)*(current_time- 
             -time_start)+pos_start
 132   1            }
 133   1            distance=desired_distance-*currnt_pos;
 134   1            *currnt_pos=desired_distance;// change to sync with step movement
 135   1            if(distance>0)
 136   1            {
 137   1              Move(distance,1);// counter clock wise
 138   1            }
 139   1            else if(distance<0)
 140   1            {
 141   1              Move(-distance,0);// clock wise
 142   1            }
 143   1            else
 144   1            {
 145   1            } 
 146   1            
 147   1            break;
 148   1            
 149   1          }
 150   1          
 151   1        }*/
 152   1        
 153   1        for(i=0;i<num_of_time_stamp;i++)// 13 diff values of time stamp
 154   1        {
 155   2          if (BCDtoDec1(hurs)==Time_stamp_PM[i][0] && BCDtoDec1(mns)== Time_stamp_PM[i][1] && BCDtoDec1(sconds&0x7
             -f)==Time_stamp_PM[i][2])// check if current time match the time stamp in the table
 156   2          {     
 157   3            desired_distance=pos_interpolate_12_17h[i][0];//18July2018 is stored in the 1st column
 158   3          }
 159   2            
 160   2            //desired_distance=receiver_pos[0][4];;
 161   2            //distance=11;
 162   2            distance=desired_distance-*currnt_pos;
 163   2            *currnt_pos=desired_distance;// change to sync with step movement
 164   2            if(distance>0)
 165   2            {
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      08/15/2018 10:35:36 PAGE 4   

 166   3              Move(distance,1);// counter clock wise
 167   3            }
 168   2            else if(distance<0)
 169   2            {
 170   3              Move(-distance,0);// clock wise
 171   3            }
 172   2            else
 173   2            {
 174   3            } 
 175   2            
 176   2          }
 177   1          if ((i+1)<num_of_time_stamp && ((BCDtoDec1(hurs)*60+BCDtoDec1(mns))<=(Time_stamp_PM[i+1][0]*60+Time_stam
             -p_PM[i+1][1])) && ((BCDtoDec1(hurs)*60+BCDtoDec1(mns))>=(Time_stamp_PM[i][0]*60+Time_stamp_PM[i][1])) && BCDtoDec1(scond
             -s&0x7f)%30==0)// update every 30 sec
 178   1          {
 179   2      
 180   2            desired_distance=linear_interpolate(Time_stamp_PM[i][0],Time_stamp_PM[i+1][0],pos_interpolate_12_17h[i]
             -[0],pos_interpolate_12_17h[i+1][0],hurs+mns/60+sconds&0x7f/3600);
 181   2            distance=desired_distance-*currnt_pos;
 182   2            *currnt_pos=desired_distance;// change to sync with step movement
 183   2            if(distance>0)
 184   2            {
 185   3              Move(distance,1);// counter clock wise
 186   3            }
 187   2            else if(distance<0)
 188   2            {
 189   3              Move(-distance,0);// clock wise
 190   3            }
 191   2            else
 192   2            {
 193   3            } 
 194   2            
 195   2            
 196   2          }
 197   1          
 198   1        }
 199          
 200          //
 201          /*
 202            for(i=0;i<13;i++)
 203            {
 204              if (BCDtoDec1(hurs)<=Time_stamp_PM[i+1][0] && BCDtoDec1(hurs)>=Time_stamp_PM[i][0] && BCDtoDec1(mns)>= T
             -ime_stamp_PM[i][1] && BCDtoDec1(mns)<= Time_stamp_PM[i+1][1] && BCDtoDec1(mns)%5==0)
 205              {
 206                desired_distance=(receiver_pos[i+1][0]-receiver_pos[i][0])/(Time_stamp_PM[i+1][0]*60+Time_stamp_PM[i+1]
             -[1]-Time_stamp_PM[i][0]*60-Time_stamp_PM[i][1])*(BCDtoDec1(hurs)*60+BCDtoDec1(mns)-Time_stamp_PM[i][0]*60-Time_stamp_PM[
             -i][1])+receiver_pos[i][0];
 207              }
 208            }
 209          */
 210          
 211          //int Day_Of_Year(unsigned char months,unsigned char days)*/

C51 COMPILATION COMPLETE.  0 WARNING(S),  5 ERROR(S)
