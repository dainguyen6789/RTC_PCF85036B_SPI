C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXT
                    -END PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          #include "SunPos.h"
   6          //#include "PCF85963BTL.h"
   7          void Delay_ms(unsigned int ms);
   8          int Day_Of_Year(unsigned char months,unsigned char days);
   9          unsigned char BCDtoDec1(char bcd);
  10          float  degree;
  11          unsigned char previous_move_time=0;
  12          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  13                      float  a21, float  a22, float  a23, float  a24,
  14                      float  a31, float  a32, float  a33, float  a34,
  15                      float  a41, float  a42, float  a43, float  a44 );
  16           float  findDet3x3( 
  17                      float  a11, float  a12, float  a13, 
  18                      float  a21, float  a22, float  a23,
  19                      float  a31, float  a32, float  a33 );           
  20          float
  21          cubic_interpolate (float *p1, float *p2, float *p3, float *p4, float x);
  22          
  23          unsigned char BCDtoDec1(unsigned char bcd)
  24          {
  25   1        unsigned char hi,lo;
  26   1        hi=bcd>>4;
  27   1        lo=bcd&0x0F;
  28   1        return hi*10+lo;
  29   1      }
  30          
  31          
  32          
  33          
  34          
  35          void Step_move(unsigned int step, bit dir)
  36          {
  37   1            unsigned int i=0;
  38   1            if(dir)
  39   1              P4 |=(1<<2);// set bit P4.2
  40   1            else
  41   1              P4 &=~(1<<2);// clear bit P4.2
  42   1            
  43   1            for( i=0;i<step;i++)
  44   1            {
  45   2                P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
  46   2                Wait_ms(2);
  47   2                P4 &= ~(1<<1);
  48   2                Wait_ms(2);
  49   2            }
  50   1      }
  51          
  52          
  53          // P4.5 direction; P4.3 pulse
  54          void Step_move_2ndMotor(unsigned int step, bit dir)
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 2   

  55          {
  56   1            unsigned int i=0;
  57   1            if(dir)
  58   1              P4 |=(1<<5);// set bit P4.5
  59   1            else
  60   1              P4 &=~(1<<5);// clear bit P4.5
  61   1            
  62   1            for( i=0;i<step;i++)
  63   1            {
  64   2                P4 |=1<<3;// P43=1 // moving distance (mm)=pi^2*step*4/675
  65   2                Wait_ms(2);
  66   2                P4 &= ~(1<<3);
  67   2                Wait_ms(2);
  68   2            }
  69   1      }
  70          
  71          void Move_2ndMotor(float  angle_distance, bit direction)
  72          {
  73   1          unsigned int step;
  74   1          step= (unsigned int)(angle_distance/0.039);// use geared motor 
  75   1          //https://www.omc-stepperonline.com/geared-stepper-motor/nema-23-stepper-motor-bipolar-l76mm-w-gear-raio
             --471-planetary-gearbox-23hs30-2804s-pg47.html
  76   1          Step_move_2ndMotor(step,direction);
  77   1      }
  78          
  79          void Move(float  distance, bit direction)
  80          {
  81   1          unsigned int step;
  82   1          step= (unsigned int)(distance*337.5/(3.14159));
  83   1          Step_move(step,direction);
  84   1      }
  85          //=====================================================
  86          //We need 4 points for cubic interpolation, p1[x],p1[y],..,p4[x],p4[y]
  87           float  findDet3x3( 
  88                      float  a11, float  a12, float  a13, 
  89                      float  a21, float  a22, float  a23,
  90                      float  a31, float  a32, float  a33 )
  91          {
  92   1          return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
  93   1                  a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
  94   1      }
  95          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  96                      float  a21, float  a22, float  a23, float  a24,
  97                      float  a31, float  a32, float  a33, float  a34,
  98                      float  a41, float  a42, float  a43, float  a44 )
  99          {
 100   1        
 101   1          //return a11*(float)findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44);
 102   1          //return (float)findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44);
 103   1          //return (float)findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44);
 104   1          //return (float)findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43);
 105   1        //  return a21;
 106   1          return( a11*findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44) -
 107   1                  a12*findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44) +
 108   1                  a13*findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44) -
 109   1                  a14*findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43));
 110   1      }
 111              
 112          //===================================================== 
 113          
 114           
 115          //===================================================== 
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 3   

 116          float  linear_interpolate(struct point p1,struct point p2, float  x)
 117          {
 118   1        float  fx;
 119   1        
 120   1        fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
 121   1        
 122   1        return fx;
 123   1      }
 124          
 125          
 126          
 127          void Update_position(unsigned char mnths,unsigned char dys,
 128                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 129                               float  *currnt_pos, float offset_calib,float  *currnt_angle)
 130          {
 131   1        unsigned int date,i=0,yy=0;
 132   1        
 133   1        float  desired_distance=0,distance=0,angle_distance=0,JP_pos=0,angle,JP_angle=0;
 134   1        float  pos_interpolate_azimuth[num_of_azimuth_stamp],angle_interpolate_azimuth[num_of_azimuth_stamp],curr
             -ent_local_sun_time,azimuth, elevation,time_offset,UTC_time=-5;
 135   1        float declination;
 136   1        struct point p1,p2;
 137   1        struct cTime time;
 138   1        struct cLocation location;
 139   1        struct cSunCoordinates *sunCoord;
 140   1        //hurs=hurs-1;// change to sun time
 141   1        //dys=dys+4;
 142   1        location.dLongitude=-73.6495;
 143   1        location.dLatitude=45.478889;
 144   1        time.iYear=2018;
 145   1        time.iMonth=BCDtoDec1(mnths);
 146   1        time.iDay=BCDtoDec1(dys);
 147   1        time.dHours=BCDtoDec1(hurs);
 148   1        time.dMinutes=BCDtoDec1(mns);
 149   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 150   1      
 151   1        
 152   1        desired_distance=*currnt_pos;
 153   1        angle=*currnt_angle;
 154   1        //date=Day_Of_Year(mnths,dys)+4;
 155   1        //date=237;
 156   1        declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
*** WARNING C182 IN LINE 156 OF BipolarMotor.c: pointer to different objects
 157   1        time_offset=1/60*(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(time.iDay-81)/365)*pi/180)    -   
             - 7.53*cos((360*(time.iDay-81)/365)*pi/180)    -   1.5*sin((360*(time.iDay-81)/365)*pi/180));
 158   1        current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=su
             -n time= clock time -1
 159   1        //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 160   1        elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 161   1                  cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
             -          );
 162   1        azimuth=180+(180/pi)*asin(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin
             -((90-elevation)*pi/180)          );// JP calculation
 163   1        //azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((
             -90-elevation)*pi/180)          );// JP calculation
 164   1      
 165   1        
 166   1        if(BCDtoDec1(sconds&0x7f)%2==0)
 167   1        {
 168   2          // interpolate for azimuth
 169   2          for (i=0;i<num_of_azimuth_stamp;i++)
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 4   

 170   2          {
 171   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 172   3            {
 173   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 174   4              {
 175   5                p1.x=date_azimuth_mapping[i];
 176   5                p2.x=date_azimuth_mapping[i+1];
 177   5                
 178   5                p1.y=RX_pos[yy][i];
 179   5                p2.y=RX_pos[yy][i+1];
 180   5                
 181   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 182   5              }
 183   4              //break;
 184   4            }
 185   3            else if ((azimuth<=date_azimuth_mapping_symmetry_side[i]) && (azimuth>=date_azimuth_mapping_symmetry_si
             -de[i+1]))
 186   3            {
 187   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 188   4              {
 189   5                p1.x=date_azimuth_mapping_symmetry_side[i];
 190   5                p2.x=date_azimuth_mapping_symmetry_side[i+1];
 191   5                
 192   5                p1.y=RX_pos[yy][i];
 193   5                p2.y=RX_pos[yy][i+1];
 194   5                
 195   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 196   5              }
 197   4              //break;
 198   4            }
 199   3            
 200   3          }
 201   2      
 202   2          // interpolate for elevation
 203   2          for(i=0;i<num_of_elevation_stamp;i++)
 204   2          {
 205   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 206   3            {
 207   4              p1.x=elevation_stamp[i];
 208   4              p2.x=elevation_stamp[i+1];
 209   4              
 210   4              p1.y=pos_interpolate_azimuth[i];
 211   4              p2.y=pos_interpolate_azimuth[i+1];
 212   4              
 213   4              JP_pos=linear_interpolate(p1,p2,elevation);
 214   4              //break;
 215   4              
 216   4            }
 217   3            
 218   3          }
 219   2          
 220   2          desired_distance=27+2*JP_pos +offset_calib;
 221   2          
 222   2          distance=desired_distance-*currnt_pos;
 223   2          if(abs(distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is more t
             -han 0.5mm OR >30s
 224   2          {
 225   3            if(distance>0)
 226   3              Move(distance,1);
 227   3            else if (distance<0)
 228   3              Move(-distance,0);
 229   3            previous_move_time=BCDtoDec1(sconds&0x7f);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 5   

 230   3            *currnt_pos=desired_distance;
 231   3          }
 232   2          
 233   2          //============================================================
 234   2          // MOVEMENT CONTROL FOR ANGLE ROTATION
 235   2          // Interpolate for azimuth
 236   2          //============================================================
 237   2          
 238   2          for (i=0;i<num_of_azimuth_stamp;i++)
 239   2          {
 240   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 241   3            {
 242   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 243   4              {
 244   5                p1.x=date_azimuth_mapping[i];
 245   5                p2.x=date_azimuth_mapping[i+1];
 246   5                
 247   5                p1.y=RX_angle[yy][i];
 248   5                p2.y=RX_angle[yy][i+1];
 249   5                
 250   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 251   5              }
 252   4              //break;
 253   4            }
 254   3            else if ((azimuth<=date_azimuth_mapping_symmetry_side[i]) && (azimuth>=date_azimuth_mapping_symmetry_si
             -de[i+1]))
 255   3            {
 256   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 257   4              {
 258   5                p1.x=date_azimuth_mapping_symmetry_side[i];
 259   5                p2.x=date_azimuth_mapping_symmetry_side[i+1];
 260   5                
 261   5                p1.y=RX_angle[yy][i];
 262   5                p2.y=RX_angle[yy][i+1];
 263   5                
 264   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 265   5              }
 266   4              //break;
 267   4            }
 268   3            
 269   3          }
 270   2          // MOVEMENT CONTROL FOR ANGLE ROTATION
 271   2          // interpolate for elevation
 272   2          for(i=0;i<num_of_elevation_stamp;i++)
 273   2          {
 274   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 275   3            {
 276   4              p1.x=elevation_stamp[i];
 277   4              p2.x=elevation_stamp[i+1];
 278   4              
 279   4              p1.y=angle_interpolate_azimuth[i];
 280   4              p2.y=angle_interpolate_azimuth[i+1];
 281   4              
 282   4              JP_angle=linear_interpolate(p1,p2,elevation);
 283   4              //break;
 284   4              
 285   4            }
 286   3            
 287   3          }
 288   2              
 289   2          angle_distance=JP_angle-*currnt_angle;
 290   2          if(abs(angle_distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is 
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 6   

             -more than 0.5mm OR >30s
 291   2          {
 292   3            if(angle_distance>0)
 293   3              Move_2ndMotor(angle_distance,1);
 294   3            else if (angle_distance<0)
 295   3              Move_2ndMotor(-angle_distance,0);
 296   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 297   3            *currnt_angle=JP_angle;
 298   3          }
 299   2          
 300   2        }
 301   1        return;
 302   1      
 303   1      }
*** WARNING C280 IN LINE 131 OF BipolarMotor.c: 'date': unreferenced local variable
 304          
 305          
 306          
 307          
 308          /*void Update_angle(unsigned char mnths,unsigned char dys,
 309                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 310                               float  *currnt_angle, float offset_calib)
 311          {
 312            unsigned int date,i=0,yy=0;
 313            
 314            float  desired_distance=0,distance=0,JP_pos=0;
 315            float  angle_interpolate_azimuth[num_of_azimuth_stamp],current_local_sun_time,azimuth, elevation,time_off
             -set,UTC_time=-5;
 316            float declination;
 317            struct point p1,p2;
 318            struct cTime time;
 319            struct cLocation location;
 320            struct cSunCoordinates *sunCoord;
 321            //hurs=hurs-1;// change to sun time
 322            //dys=dys+4;
 323            location.dLongitude=-73.6495;
 324            location.dLatitude=45.478889;
 325            time.iYear=2018;
 326            time.iMonth=BCDtoDec1(mnths);
 327            time.iDay=BCDtoDec1(dys);
 328            time.dHours=BCDtoDec1(hurs);
 329            time.dMinutes=BCDtoDec1(mns);
 330            time.dSeconds=BCDtoDec1(sconds&0x7f);
 331          
 332            
 333            desired_distance=*currnt_angle;
 334            
 335            //date=Day_Of_Year(mnths,dys)+4;
 336            //date=237;
 337            declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
 338            time_offset=1/60*(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(time.iDay-81)/365)*pi/180)    -   
             - 7.53*cos((360*(time.iDay-81)/365)*pi/180)    -   1.5*sin((360*(time.iDay-81)/365)*pi/180));
 339            current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=su
             -n time= clock time -1
 340            //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 341            elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 342                      cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
             -          );
 343            azimuth=180+(180/pi)*asin(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin
             -((90-elevation)*pi/180)          );// JP calculation
 344          
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 7   

 345            
 346            if(BCDtoDec1(sconds&0x7f)%2==0)
 347            {
 348              // interpolate for azimuth
 349              for (i=0;i<num_of_azimuth_stamp;i++)
 350              {
 351                if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 352                {
 353                  for (yy=0;yy<num_of_elevation_stamp;yy++)
 354                  {
 355                    p1.x=date_azimuth_mapping[i];
 356                    p2.x=date_azimuth_mapping[i+1];
 357                    
 358                    p1.y=RX_angle[yy][i];
 359                    p2.y=RX_angle[yy][i+1];
 360                    
 361                    angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 362                  }
 363                  //break;
 364                }
 365              }
 366          
 367              // interpolate for elevation
 368              for(i=0;i<num_of_elevation_stamp;i++)
 369              {
 370                if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 371                {
 372                  p1.x=elevation_stamp[i];
 373                  p2.x=elevation_stamp[i+1];
 374                  
 375                  p1.y=angle_interpolate_azimuth[i];
 376                  p2.y=angle_interpolate_azimuth[i+1];
 377                  
 378                  JP_pos=linear_interpolate(p1,p2,elevation);
 379                  //break;
 380                  
 381                }
 382                
 383              }
 384              
 385              desired_distance=27+2*JP_pos +offset_calib;
 386              
 387              distance=desired_distance-*currnt_angle;
 388              if(abs(distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is more t
             -han 0.5mm OR >30s
 389              {
 390                if(distance>0)
 391                  Move(distance,1);
 392                else if (distance<0)
 393                  Move(-distance,0);
 394                previous_move_time=BCDtoDec1(sconds&0x7f);
 395                *currnt_angle=desired_distance;
 396              }
 397            }
 398            return;
 399          
 400          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5308    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      10/31/2018 12:03:16 PAGE 8   

   XDATA SIZE       =    969     326
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
