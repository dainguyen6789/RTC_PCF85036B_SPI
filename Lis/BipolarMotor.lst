C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXTEND
                    - PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          #include "SunPos.h"
   6          #include "KeyPad.h"
   7          //#include "PCF85963BTL.h"
   8          //#include "PCF85063BTL.h"
   9          
  10          void Delay_ms(unsigned int ms);
  11          int Day_Of_Year(unsigned char months,unsigned char days);
  12          unsigned char BCDtoDec1(char bcd);
  13          void Display_Pos(float sign_dat);
  14          void WriteData(unsigned char dat);
  15          void Command(unsigned char dat);
  16          
  17          int lcd=0;
  18          float  degree;
  19          unsigned char previous_move_time=0;
  20          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  21                      float  a21, float  a22, float  a23, float  a24,
  22                      float  a31, float  a32, float  a33, float  a34,
  23                      float  a41, float  a42, float  a43, float  a44 );
  24           float  findDet3x3( 
  25                      float  a11, float  a12, float  a13, 
  26                      float  a21, float  a22, float  a23,
  27                      float  a31, float  a32, float  a33 );           
  28          float
  29          cubic_interpolate (float *p1, float *p2, float *p3, float *p4, float x);
  30          
  31          unsigned char BCDtoDec1(unsigned char bcd)
  32          {
  33   1        unsigned char hi,lo;
  34   1        hi=bcd>>4;
  35   1        lo=bcd&0x0F;
  36   1        return hi*10+lo;
  37   1      }
  38          
  39          
  40          
  41          
  42          
  43          void Step_move(unsigned int step, bit dir)
  44          {
  45   1            unsigned int i=0;
  46   1            if(dir)
  47   1              P4 |=(1<<2);// set bit P4.2
  48   1            else
  49   1              P4 &=~(1<<2);// clear bit P4.2
  50   1            
  51   1            //for( i=0;i<step;i++)
  52   1            {
  53   2                P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
  54   2                Wait_ms(2);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 2   

  55   2                P4 &= ~(1<<1);
  56   2                Wait_ms(2);
  57   2            }
  58   1      }
*** WARNING C280 IN LINE 43 OF BipolarMotor.c: 'step': unreferenced local variable
  59          
  60          
  61          // P4.5 direction; P4.3 pulse
  62          void Step_move_2ndMotor(unsigned int step, bit dir)
  63          {
  64   1            unsigned int i=0;
  65   1            if(dir)
  66   1              P4 |=(1<<5);// set bit P4.5
  67   1            else
  68   1              P4 &=~(1<<5);// clear bit P4.5
  69   1            
  70   1            //for( i=0;i<step;i++)
  71   1            {
  72   2                P3 |=1<<4;// P43=1 // moving distance (mm)=pi^2*step*4/675
  73   2                Wait_ms(2);
  74   2                P3 &= ~(1<<4);
  75   2                Wait_ms(2);
  76   2            }
  77   1      }
*** WARNING C280 IN LINE 62 OF BipolarMotor.c: 'step': unreferenced local variable
  78          
  79          void Move_2ndMotor(float  angle_distance, bit direction,float current_angle)
  80          {
  81   1          unsigned int step,i;
  82   1          //step= (unsigned int)(angle_distance/0.039);// use geared motor // Dai
  83   1          //  https://www.omc-stepperonline.com/geared-stepper-motor/nema-23-stepper-motor-bipolar-l76mm-w-gear-rai
             -o-471-planetary-gearbox-23hs30-2804s-pg47.html
  84   1          // we have another gear on the shaft with ratio 1:1
  85   1        
  86   1          step= (unsigned int)(angle_distance/0.0122);  // jk 26 March 2019 motor 1.8 deg , with gear ration 50:1
             -, one pulley 2R=183.2mm ( with belt), another 2R= 61.87mm
  87   1        
  88   1          for( i=0;i<step;i++)
  89   1          {
  90   2            Step_move_2ndMotor(step,direction);
  91   2            if(direction)
  92   2              current_angle=current_angle+0.0122;   // for LCD display only, before 0.039
  93   2            else
  94   2              current_angle=current_angle-0.0122;   // for LCD display only, before 0.039
  95   2            if(i%50==0)
  96   2            {
  97   3              Command(0x08);
  98   3              Command(0x09);
  99   3              selected_motor=1;
 100   3              Display_Pos(current_angle);
 101   3            }
 102   2          }
 103   1      }
 104          
 105          void Move(float  distance, bit direction,float current_position)
 106          {
 107   1          unsigned long int step,i;
 108   1          //int i;
 109   1      //    step= (unsigned long int)(distance*17.7);// num of steps=distance*180/(2*pi*R*0.039); step angle = 0.0
             -39, R=83/2mm  //Dai
 110   1            step= (unsigned long int)(distance*39.939); // num of steps=distance*360/(2*pi*R*0.036); step angle =
             - 0.039, R=79.7/2mm  //jk 26 March 2019
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 3   

 111   1        
 112   1          for( i=0;i<step;i++)
 113   1          {
 114   2            Step_move(step,direction);// move one step
 115   2            if(direction)
 116   2              current_position=current_position+0.02504;  //before 0.0565
 117   2            else
 118   2              current_position=current_position-0.02504;   //before 0.0565
 119   2            if(i%50==0)
 120   2            {     
 121   3              Command(0x08);
 122   3              Command(0x09);
 123   3              selected_motor=0;
 124   3              Display_Pos(current_position);
 125   3            }
 126   2          }
 127   1      }
 128          //=====================================================
 129          //We need 4 points for cubic interpolation, p1[x],p1[y],..,p4[x],p4[y]
 130           float  findDet3x3( 
 131                      float  a11, float  a12, float  a13, 
 132                      float  a21, float  a22, float  a23,
 133                      float  a31, float  a32, float  a33 )
 134          {
 135   1          return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
 136   1                  a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
 137   1      }
 138          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
 139                      float  a21, float  a22, float  a23, float  a24,
 140                      float  a31, float  a32, float  a33, float  a34,
 141                      float  a41, float  a42, float  a43, float  a44 )
 142          {
 143   1        
 144   1          //return a11*(float)findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44);
 145   1          //return (float)findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44);
 146   1          //return (float)findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44);
 147   1          //return (float)findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43);
 148   1        //  return a21;
 149   1          return( a11*findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44) -
 150   1                  a12*findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44) +
 151   1                  a13*findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44) -
 152   1                  a14*findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43));
 153   1      }
 154              
 155          //===================================================== 
 156          
 157           
 158          //===================================================== 
 159          float  linear_interpolate(struct point p1,struct point p2, float  x)
 160          {
 161   1        float  fx;
 162   1        
 163   1        fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
 164   1        
 165   1        return fx;
 166   1      }
 167          
 168          
 169          
 170          void Update_position(unsigned char mnths,unsigned char dys,
 171                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 172                               float  *currnt_pos, float offset_calib,float  *currnt_angle)
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 4   

 173          {
 174   1        //We use all the time Summer time
 175   1        unsigned int date,i=0,yy=0;
 176   1        
 177   1        
 178   1        float  desired_distance=0,distance=0,angle_distance=0,JP_pos=0,angle,JP_angle=0;
 179   1        float  pos_interpolate_azimuth[num_of_azimuth_stamp],angle_interpolate_azimuth[num_of_azimuth_stamp],curr
             -ent_local_sun_time,azimuth, elevation,time_offset,UTC_time=-8;
 180   1        float declination;
 181   1        struct point p1,p2;
 182   1        struct cTime time;
 183   1        struct cLocation location;
 184   1        struct cSunCoordinates *sunCoord;
 185   1        //hurs=hurs-1;// change to sun time
 186   1        //dys=dys+4;
 187   1        location.dLongitude= -123.232451;  //Montreal-73.6495;   // Vancouver -123.232451 
 188   1        location.dLatitude=    45.245621;     //Montreal45.478889;  // vancouver 45.245621
 189   1        time.iYear=2019;
 190   1        time.iMonth=BCDtoDec1(mnths);
 191   1        time.iDay=BCDtoDec1(dys);
 192   1        time.dHours=BCDtoDec1(hurs);
 193   1        time.dMinutes=BCDtoDec1(mns);
 194   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 195   1        
 196   1        
 197   1        
 198   1        
 199   1        desired_distance=*currnt_pos;
 200   1        //desired_angle=*currnt_angle;
 201   1        date=Day_Of_Year(mnths,dys);
 202   1        //date=237;
 203   1        declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
*** WARNING C182 IN LINE 203 OF BipolarMotor.c: pointer to different objects
 204   1        time_offset=(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(date-81)/365)*pi/180) -7.53*cos((360*(d
             -ate-81)/365)*pi/180) -1.5*sin((360*(date-81)/365)*pi/180))/60;
 205   1      
 206   1        current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=s
             -un time= clock time -1
 207   1        //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 208   1        elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 209   1                  cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
             -          );
 210   1        azimuth=sin((15*(current_local_sun_time-12))*pi/180);
 211   1        azimuth=azimuth*cos(declination*pi/180);
 212   1        azimuth=azimuth/sin((90-elevation)*pi/180);
 213   1        azimuth=asin(azimuth);
 214   1        azimuth=azimuth*(180/pi);
 215   1        azimuth=azimuth+180;
 216   1        
 217   1      //  azimuth=180+(180/pi)*asin(sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((90-
             -elevation)*pi/180));// JP calculation
 218   1        //azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((
             -90-elevation)*pi/180)          );// JP calculation
 219   1      
 220   1        
 221   1        if(BCDtoDec1(sconds&0x7f)%2==0)
 222   1        {
 223   2          // interpolate for azimuth
 224   2          for (i=0;i<num_of_azimuth_stamp;i++)
 225   2          {
 226   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 5   

 227   3            {
 228   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 229   4              {
 230   5                p1.x=date_azimuth_mapping[i];
 231   5                p2.x=date_azimuth_mapping[i+1];
 232   5                
 233   5                p1.y=RX_pos[yy][i];
 234   5                p2.y=RX_pos[yy][i+1];
 235   5                
 236   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 237   5              }
 238   4              //break;
 239   4            }
 240   3            else if ((azimuth<=date_azimuth_mapping_symmetry_side[i]) && (azimuth>=date_azimuth_mapping_symmetry_si
             -de[i+1]))
 241   3            {
 242   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 243   4              {
 244   5                p1.x=date_azimuth_mapping_symmetry_side[i];
 245   5                p2.x=date_azimuth_mapping_symmetry_side[i+1];
 246   5                
 247   5                p1.y=RX_pos[yy][i];
 248   5                p2.y=RX_pos[yy][i+1];
 249   5                
 250   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 251   5              }
 252   4              //break;
 253   4            }
 254   3            
 255   3          }
 256   2      
 257   2          // interpolate for elevation
 258   2          for(i=0;i<num_of_elevation_stamp;i++)
 259   2          {
 260   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 261   3            {
 262   4              p1.x=elevation_stamp[i];
 263   4              p2.x=elevation_stamp[i+1];
 264   4              
 265   4              p1.y=pos_interpolate_azimuth[i];
 266   4              p2.y=pos_interpolate_azimuth[i+1];
 267   4              
 268   4              JP_pos=linear_interpolate(p1,p2,elevation);
 269   4              //break;
 270   4              
 271   4            }
 272   3            
 273   3          }
 274   2          
 275   2          desired_distance=JP_pos;// +offset_calib;
 276   2          //desired_distance=elevation;// +offset_calib;
 277   2          //desired_distance=azimuth;// +offset_calib;
 278   2          //desired_distance=declination;// +offset_calib;
 279   2      
 280   2          distance=desired_distance-*currnt_pos;
 281   2          if(abs(distance)>5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>60)// move if the change is more tha
             -n 5mm OR >60s // jk changed before  0.5mm and 30 sec
 282   2          {
 283   3            if(distance>0)
 284   3              Move(distance,1,*currnt_pos);
 285   3            else if (distance<0)
 286   3              Move(-distance,0,*currnt_pos);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 6   

 287   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 288   3            *currnt_pos=desired_distance;
 289   3          }
 290   2          
 291   2          //============================================================
 292   2          // MOVEMENT CONTROL FOR ANGLE ROTATION
 293   2          // Interpolate for azimuth
 294   2          //============================================================
 295   2          
 296   2          for (i=0;i<num_of_azimuth_stamp;i++)
 297   2          {
 298   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 299   3            {
 300   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 301   4              {
 302   5                p1.x=date_azimuth_mapping[i];
 303   5                p2.x=date_azimuth_mapping[i+1];
 304   5                
 305   5                p1.y=RX_angle[yy][i];
 306   5                p2.y=RX_angle[yy][i+1];
 307   5                
 308   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 309   5              }
 310   4              //break;
 311   4            }
 312   3            else if ((azimuth<=date_azimuth_mapping_symmetry_side[i]) && (azimuth>=date_azimuth_mapping_symmetry_si
             -de[i+1]))
 313   3            {
 314   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 315   4              {
 316   5                p1.x=date_azimuth_mapping_symmetry_side[i];
 317   5                p2.x=date_azimuth_mapping_symmetry_side[i+1];
 318   5                
 319   5                p1.y=RX_angle[yy][i];
 320   5                p2.y=RX_angle[yy][i+1];
 321   5                
 322   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 323   5              }
 324   4              //break;
 325   4            }
 326   3            
 327   3          }
 328   2          // MOVEMENT CONTROL FOR ANGLE ROTATION
 329   2          // interpolate for elevation
 330   2          for(i=0;i<num_of_elevation_stamp;i++)
 331   2          {
 332   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 333   3            {
 334   4              p1.x=elevation_stamp[i];
 335   4              p2.x=elevation_stamp[i+1];
 336   4              
 337   4              p1.y=angle_interpolate_azimuth[i];
 338   4              p2.y=angle_interpolate_azimuth[i+1];
 339   4              
 340   4              JP_angle=linear_interpolate(p1,p2,elevation);
 341   4              //break;
 342   4              
 343   4            }
 344   3            
 345   3          }
 346   2              
 347   2          angle_distance=JP_angle-*currnt_angle;
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 7   

 348   2          if(abs(angle_distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is 
             -more than 0.5mm OR >30s
 349   2          {
 350   3            if(angle_distance>0)
 351   3              Move_2ndMotor(angle_distance,1,*currnt_angle);
 352   3            else if (angle_distance<0)
 353   3              Move_2ndMotor(-angle_distance,0,*currnt_angle);
 354   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 355   3            *currnt_angle=JP_angle;
 356   3          }
 357   2          
 358   2        }
 359   1        return;
 360   1      
 361   1      }
*** WARNING C280 IN LINE 172 OF BipolarMotor.c: 'offset_calib': unreferenced local variable
*** WARNING C280 IN LINE 178 OF BipolarMotor.c: 'angle': unreferenced local variable
 362          
 363          void Display_Pos(float sign_dat)
 364          {
 365   1        unsigned char unit, ten, hundred,thousand;
 366   1        unsigned char after_dot;
 367   1        int dat;
 368   1        dat=abs(sign_dat);
 369   1        if (sign_dat>0)
 370   1          after_dot=(unsigned char)((sign_dat-dat)*10);
 371   1        else
 372   1          after_dot=(unsigned char)((-sign_dat-dat)*10);
 373   1        
 374   1        unit =dat%10;// remainder after division
 375   1        thousand=dat/1000;
 376   1        hundred=(dat-thousand*1000)/100;
 377   1        ten=(dat-thousand*1000-hundred*100)/10;
 378   1        if (sign_dat>=0)
 379   1        {
 380   2          WriteData(thousand|0x30);
 381   2          WriteData(hundred|0x30);
 382   2          WriteData(ten|0x30);
 383   2          WriteData(unit|0x30);
 384   2          WriteData(0x2E);//.
 385   2          WriteData((after_dot)|0x30);
 386   2          if(!selected_motor)
 387   2          {
 388   3            WriteData(0x6D);//m
 389   3            WriteData(0x6D);//m
 390   3            WriteData(0x20);// "blank"
 391   3            //WriteData(0x20);// "blank"
 392   3            //WriteData(0x20);// "blank"
 393   3          }
 394   2          else
 395   2          {
 396   3            WriteData(0xDF);// "blank"
 397   3            WriteData(0x20);// "blank"
 398   3            WriteData(0x20);// "blank"
 399   3          }
 400   2        }
 401   1        else
 402   1        {
 403   2          
 404   2          WriteData(0x2D);// "-"
 405   2          WriteData(thousand|0x30);
 406   2          WriteData(hundred|0x30);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      03/27/2019 14:42:33 PAGE 8   

 407   2          WriteData(ten|0x30);
 408   2          WriteData(unit|0x30);
 409   2          WriteData(0x2E);//"."
 410   2          WriteData(after_dot|0x30);
 411   2          if(!selected_motor)
 412   2          {
 413   3            WriteData(0x6D);//m
 414   3            WriteData(0x6D);//m
 415   3            WriteData(0x20);// "blank"
 416   3            //WriteData(0x20);// "blank"
 417   3            //WriteData(0x20);// "blank"
 418   3          }
 419   2          else
 420   2          {
 421   3            WriteData(0xDF);// "blank"
 422   3            WriteData(0x20);// "blank"
 423   3            WriteData(0x20);// "blank"
 424   3          }
 425   2          //WriteData(0x6D);//m
 426   2          //WriteData(0x6D);//m
 427   2      
 428   2        }
 429   1        return;
 430   1      }
 431          
 432          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6507    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1307     361
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
