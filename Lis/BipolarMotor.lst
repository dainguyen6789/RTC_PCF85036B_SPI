C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXTEND
                    - PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          #include "SunPos.h"
   6          #include "KeyPad.h"
   7          #include "PI4IOE5V96248.h"
   8          
   9          //#include "PCF85963BTL.h"
  10          //#include "PCF85063BTL.h"
  11          
  12          void Delay_ms(unsigned int ms);
  13          int Day_Of_Year(unsigned char months,unsigned char days);
  14          unsigned char BCDtoDec1(char bcd);
  15          void Write_PI4IOE5V96248(struct DATA_FOR_IO_6PORTS *xdat);
  16          void Display_Pos(float sign_dat);
  17          void WriteData(unsigned char dat);
  18          void Command(unsigned char dat);
  19          
  20          
  21          
  22          int lcd=0;
  23          float  degree;
  24          unsigned char previous_move_time=0;
  25          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  26                      float  a21, float  a22, float  a23, float  a24,
  27                      float  a31, float  a32, float  a33, float  a34,
  28                      float  a41, float  a42, float  a43, float  a44 );
  29           float  findDet3x3( 
  30                      float  a11, float  a12, float  a13, 
  31                      float  a21, float  a22, float  a23,
  32                      float  a31, float  a32, float  a33 );           
  33          float
  34          cubic_interpolate (float *p1, float *p2, float *p3, float *p4, float x);
  35          
  36          struct DATA_FOR_IO_6PORTS dat;
  37          
  38          unsigned char BCDtoDec1(unsigned char bcd)
  39          {
  40   1        unsigned char hi,lo;
  41   1        hi=bcd>>4;
  42   1        lo=bcd&0x0F;
  43   1        return hi*10+lo;
  44   1      }
  45          // jk with IO multplexer
  46          
  47          void vOneStepMove(bit bDir)
  48          {
  49   1        //unsigned char temp;
  50   1        if(bDir)  //pos direction
  51   1          {
  52   2            dat.port5=0x00|0x04;//port5.1 is used to move the motor, port5.0 is used to control the direction, 0x40
             - is used to set bit P52 (enable the motor driver)
  53   2            Write_PI4IOE5V96248(&dat);
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 2   

  54   2            Delay_ms(2);
  55   2            dat.port5=0x02|0x04;
  56   2            Write_PI4IOE5V96248(&dat);
  57   2            Delay_ms(2);
  58   2            
  59   2          }
  60   1        
  61   1        else      // neg direction
  62   1          {
  63   2            dat.port5=0x01|0x04;//port5.1 is used to move the motor, port5.0 is used to control the direction.
  64   2            Write_PI4IOE5V96248(&dat);
  65   2            Delay_ms(2);
  66   2            dat.port5=0x03|0x04;
  67   2            Write_PI4IOE5V96248(&dat);
  68   2            Delay_ms(2);
  69   2          } 
  70   1      }
  71          
  72          
  73          void vOneStepMove_2ndMotor(bit bDir)
  74          {
  75   1        //unsigned char temp;
  76   1        if(bDir)  //pos direction
  77   1          {
  78   2            dat.port4=0x00|0x04;//port4.1 is used to move the motor, port4.0 is used to control the direction, 0x40
             - is used to set bit P52 (enable the motor driver)
  79   2            Write_PI4IOE5V96248(&dat);
  80   2            Delay_ms(2);
  81   2            dat.port4=0x02|0x04;
  82   2            Write_PI4IOE5V96248(&dat);
  83   2            Delay_ms(2);      
  84   2          } 
  85   1        else      // neg direction
  86   1          {
  87   2            dat.port4=0x01|0x04;//port5.1 is used to move the motor, port5.0 is used to control the direction.
  88   2            Write_PI4IOE5V96248(&dat);
  89   2            Delay_ms(2);
  90   2            dat.port4=0x03|0x04;
  91   2            Write_PI4IOE5V96248(&dat);
  92   2            Delay_ms(2);
  93   2          } 
  94   1      }
  95          
  96          
  97          void Step_move(unsigned int step, bit dir)
  98          {
  99   1            unsigned int i=0;
 100   1            //P3M1=0x00;
 101   1            //P3M0=0xFF;
 102   1            for(i=0;i<step;i++)
 103   1            {
 104   2                    vOneStepMove(dir);
 105   2                    //Wait_ms(30);
 106   2            }
 107   1      }
 108          
 109          
 110          void Step_move_2ndMotor(unsigned int step, bit dir)
 111          {
 112   1            unsigned int i=0;
 113   1            //P3M1=0x00;
 114   1            //P3M0=0xFF;
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 3   

 115   1            for(i=0;i<step;i++)
 116   1            {
 117   2                    vOneStepMove_2ndMotor(dir);
 118   2                    //Wait_ms(30);
 119   2            }
 120   1      }
 121          
 122          
 123          /*
 124          void Step_move(unsigned int step, bit dir)
 125          {
 126                unsigned int i=0;
 127                if(dir)
 128                  P4 |=(1<<2);// set bit P4.2
 129                else
 130                  P4 &=~(1<<2);// clear bit P4.2
 131                
 132                //for( i=0;i<step;i++)
 133                {
 134                    P4 |=1<<1;// P41=1 // moving distance (mm)=pi^2*step*4/675
 135                    Wait_ms(2);
 136                    P4 &= ~(1<<1);
 137                    Wait_ms(2);
 138                }
 139          }
 140          */
 141          
 142          // P4.5 direction; P4.3 pulse
 143          /*
 144          void Step_move_2ndMotor(unsigned int step, bit dir)
 145          {
 146                unsigned int i=0;
 147                if(dir)
 148                  P4 |=(1<<5);// set bit P4.5
 149                else
 150                  P4 &=~(1<<5);// clear bit P4.5
 151                
 152                //for( i=0;i<step;i++)
 153                {
 154                    P3 |=1<<4;// P43=1 // moving distance (mm)=pi^2*step*4/675
 155                    Wait_ms(2);
 156                    P3 &= ~(1<<4);
 157                    Wait_ms(2);
 158                }
 159          }
 160          */
 161          void Move_2ndMotor(float  angle_distance, bit direction,float current_angle)
 162          {
 163   1          unsigned int step,i;
 164   1          //step= (unsigned int)(angle_distance/0.039);// use geared motor // Dai
 165   1          //  https://www.omc-stepperonline.com/geared-stepper-motor/nema-23-stepper-motor-bipolar-l76mm-w-gear-rai
             -o-471-planetary-gearbox-23hs30-2804s-pg47.html
 166   1          // we have another gear on the shaft with ratio 1:1
 167   1        
 168   1          step= (unsigned int)(angle_distance/0.0122);  // jk 26 March 2019 motor 1.8 deg , with gear ration 50:1
             -, one pulley 2R=183.2mm ( with belt), another 2R= 61.87mm
 169   1        
 170   1          for( i=0;i<step;i++)
 171   1          {
 172   2            Step_move_2ndMotor(step,direction);
 173   2            if(direction)
 174   2              current_angle=current_angle+0.0122;   // for LCD display only, before 0.039
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 4   

 175   2            else
 176   2              current_angle=current_angle-0.0122;   // for LCD display only, before 0.039
 177   2            if(i%50==0)
 178   2            {
 179   3              Command(0x08);
 180   3              Command(0x09);
 181   3              selected_motor=1;
 182   3              Display_Pos(current_angle);
 183   3            }
 184   2          }
 185   1      }
 186          
 187          void Move(float  distance, bit direction,float current_position)
 188          {
 189   1          unsigned long int step,i;
 190   1          //int i;
 191   1      //    step= (unsigned long int)(distance*17.7);// num of steps=distance*180/(2*pi*R*0.039); step angle = 0.0
             -39, R=83/2mm  //Dai
 192   1            step= (unsigned long int)(distance*39.939); // num of steps=distance*360/(2*pi*R*0.036); step angle =
             - 0.039, R=79.7/2mm  //jk 26 March 2019
 193   1        
 194   1          for( i=0;i<step;i++)
 195   1          {
 196   2            Step_move(step,direction);// move one step
 197   2            if(direction)
 198   2              current_position=current_position+0.02504;  //before 0.0565
 199   2            else
 200   2              current_position=current_position-0.02504;   //before 0.0565
 201   2            if(i%50==0)
 202   2            {     
 203   3              Command(0x08);
 204   3              Command(0x09);
 205   3              selected_motor=0;
 206   3              Display_Pos(current_position);
 207   3            }
 208   2          }
 209   1      }
 210          //=====================================================
 211          //We need 4 points for cubic interpolation, p1[x],p1[y],..,p4[x],p4[y]
 212           float  findDet3x3( 
 213                      float  a11, float  a12, float  a13, 
 214                      float  a21, float  a22, float  a23,
 215                      float  a31, float  a32, float  a33 )
 216          {
 217   1          return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
 218   1                  a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
 219   1      }
 220          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
 221                      float  a21, float  a22, float  a23, float  a24,
 222                      float  a31, float  a32, float  a33, float  a34,
 223                      float  a41, float  a42, float  a43, float  a44 )
 224          {
 225   1        
 226   1          //return a11*(float)findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44);
 227   1          //return (float)findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44);
 228   1          //return (float)findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44);
 229   1          //return (float)findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43);
 230   1        //  return a21;
 231   1          return( a11*findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44) -
 232   1                  a12*findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44) +
 233   1                  a13*findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44) -
 234   1                  a14*findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43));
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 5   

 235   1      }
 236              
 237          //===================================================== 
 238          
 239           
 240          //===================================================== 
 241          float  linear_interpolate(struct point p1,struct point p2, float  x)
 242          {
 243   1        float  fx;
 244   1        
 245   1        fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
 246   1        
 247   1        return fx;
 248   1      }
 249          
 250          
 251          
 252          void Update_position(unsigned char mnths,unsigned char dys,
 253                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 254                               float  *currnt_pos, float offset_calib,float  *currnt_angle)
 255          {
 256   1        //We use all the time Summer time
 257   1        unsigned int date,i=0,yy=0;
 258   1        
 259   1        
 260   1        float  desired_distance=0,distance=0,angle_distance=0,JP_pos=0,angle,JP_angle=0;
 261   1        float  pos_interpolate_azimuth[num_of_azimuth_stamp],angle_interpolate_azimuth[num_of_azimuth_stamp],curr
             -ent_local_sun_time,azimuth, elevation,time_offset,UTC_time=-8;
 262   1        float declination;
 263   1        struct point p1,p2;
 264   1        struct cTime time;
 265   1        struct cLocation location;
 266   1        struct cSunCoordinates *sunCoord;
 267   1        //hurs=hurs-1;// change to sun time
 268   1        //dys=dys+4;
 269   1        location.dLongitude= -123.232451;  //Montreal-73.6495;   // Vancouver -123.232451 
 270   1        location.dLatitude=    45.245621;     //Montreal45.478889;  // vancouver 45.245621
 271   1        time.iYear=2019;
 272   1        time.iMonth=BCDtoDec1(mnths);
 273   1        time.iDay=BCDtoDec1(dys);
 274   1        time.dHours=BCDtoDec1(hurs);
 275   1        time.dMinutes=BCDtoDec1(mns);
 276   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 277   1        
 278   1        
 279   1        
 280   1        
 281   1        desired_distance=*currnt_pos;
 282   1        //desired_angle=*currnt_angle;
 283   1        date=Day_Of_Year(mnths,dys);
 284   1        //date=237;
 285   1        declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
*** WARNING C182 IN LINE 285 OF BipolarMotor.c: pointer to different objects
 286   1        time_offset=(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(date-81)/365)*pi/180) -7.53*cos((360*(d
             -ate-81)/365)*pi/180) -1.5*sin((360*(date-81)/365)*pi/180))/60;
 287   1      
 288   1        current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=s
             -un time= clock time -1
 289   1        //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 290   1        elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 291   1                  cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 6   

             -          );
 292   1        azimuth=sin((15*(current_local_sun_time-12))*pi/180);
 293   1        azimuth=azimuth*cos(declination*pi/180);
 294   1        azimuth=azimuth/sin((90-elevation)*pi/180);
 295   1        azimuth=asin(azimuth);
 296   1        azimuth=azimuth*(180/pi);
 297   1        azimuth=azimuth+180;
 298   1        
 299   1      //  azimuth=180+(180/pi)*asin(sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((90-
             -elevation)*pi/180));// JP calculation
 300   1        //azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((
             -90-elevation)*pi/180)          );// JP calculation
 301   1      
 302   1        
 303   1        if(BCDtoDec1(sconds&0x7f)%2==0)
 304   1        {
 305   2          // interpolate for azimuth
 306   2          for (i=0;i<num_of_azimuth_stamp;i++)
 307   2          {
 308   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 309   3            {
 310   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 311   4              {
 312   5                p1.x=date_azimuth_mapping[i];
 313   5                p2.x=date_azimuth_mapping[i+1];
 314   5                
 315   5                p1.y=RX_pos[yy][i];
 316   5                p2.y=RX_pos[yy][i+1];
 317   5                
 318   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 319   5              }
 320   4              //break;
 321   4            }
 322   3            else if ((azimuth<=date_azimuth_mapping_symmetry_side[i]) && (azimuth>=date_azimuth_mapping_symmetry_si
             -de[i+1]))
 323   3            {
 324   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 325   4              {
 326   5                p1.x=date_azimuth_mapping_symmetry_side[i];
 327   5                p2.x=date_azimuth_mapping_symmetry_side[i+1];
 328   5                
 329   5                p1.y=RX_pos[yy][i];
 330   5                p2.y=RX_pos[yy][i+1];
 331   5                
 332   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 333   5              }
 334   4              //break;
 335   4            }
 336   3            
 337   3          }
 338   2      
 339   2          // interpolate for elevation
 340   2          for(i=0;i<num_of_elevation_stamp;i++)
 341   2          {
 342   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 343   3            {
 344   4              p1.x=elevation_stamp[i];
 345   4              p2.x=elevation_stamp[i+1];
 346   4              
 347   4              p1.y=pos_interpolate_azimuth[i];
 348   4              p2.y=pos_interpolate_azimuth[i+1];
 349   4              
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 7   

 350   4              JP_pos=linear_interpolate(p1,p2,elevation);
 351   4              //break;
 352   4              
 353   4            }
 354   3            
 355   3          }
 356   2          
 357   2          desired_distance=JP_pos;// +offset_calib;
 358   2          //desired_distance=elevation;// +offset_calib;
 359   2          //desired_distance=azimuth;// +offset_calib;
 360   2          //desired_distance=declination;// +offset_calib;
 361   2      
 362   2          distance=desired_distance-*currnt_pos;
 363   2          if(abs(distance)>5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>60)// move if the change is more tha
             -n 5mm OR >60s // jk changed before  0.5mm and 30 sec
 364   2          {
 365   3            if(distance>0)
 366   3              Move(distance,1,*currnt_pos);
 367   3            else if (distance<0)
 368   3              Move(-distance,0,*currnt_pos);
 369   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 370   3            *currnt_pos=desired_distance;
 371   3          }
 372   2          
 373   2          //============================================================
 374   2          // MOVEMENT CONTROL FOR ANGLE ROTATION
 375   2          // Interpolate for azimuth
 376   2          //============================================================
 377   2          
 378   2          for (i=0;i<num_of_azimuth_stamp;i++)
 379   2          {
 380   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 381   3            {
 382   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 383   4              {
 384   5                p1.x=date_azimuth_mapping[i];
 385   5                p2.x=date_azimuth_mapping[i+1];
 386   5                
 387   5                p1.y=RX_angle[yy][i];
 388   5                p2.y=RX_angle[yy][i+1];
 389   5                
 390   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 391   5              }
 392   4              //break;
 393   4            }
 394   3            else if ((azimuth<=date_azimuth_mapping_symmetry_side[i]) && (azimuth>=date_azimuth_mapping_symmetry_si
             -de[i+1]))
 395   3            {
 396   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 397   4              {
 398   5                p1.x=date_azimuth_mapping_symmetry_side[i];
 399   5                p2.x=date_azimuth_mapping_symmetry_side[i+1];
 400   5                
 401   5                p1.y=RX_angle[yy][i];
 402   5                p2.y=RX_angle[yy][i+1];
 403   5                
 404   5                angle_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 405   5              }
 406   4              //break;
 407   4            }
 408   3            
 409   3          }
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 8   

 410   2          // MOVEMENT CONTROL FOR ANGLE ROTATION
 411   2          // interpolate for elevation
 412   2          for(i=0;i<num_of_elevation_stamp;i++)
 413   2          {
 414   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 415   3            {
 416   4              p1.x=elevation_stamp[i];
 417   4              p2.x=elevation_stamp[i+1];
 418   4              
 419   4              p1.y=angle_interpolate_azimuth[i];
 420   4              p2.y=angle_interpolate_azimuth[i+1];
 421   4              
 422   4              JP_angle=linear_interpolate(p1,p2,elevation);
 423   4              //break;
 424   4              
 425   4            }
 426   3            
 427   3          }
 428   2              
 429   2          angle_distance=JP_angle-*currnt_angle;
 430   2          if(abs(angle_distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is 
             -more than 0.5mm OR >30s
 431   2          {
 432   3            if(angle_distance>0)
 433   3              Move_2ndMotor(angle_distance,1,*currnt_angle);
 434   3            else if (angle_distance<0)
 435   3              Move_2ndMotor(-angle_distance,0,*currnt_angle);
 436   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 437   3            *currnt_angle=JP_angle;
 438   3          }
 439   2          
 440   2        }
 441   1        return;
 442   1      
 443   1      }
*** WARNING C280 IN LINE 254 OF BipolarMotor.c: 'offset_calib': unreferenced local variable
*** WARNING C280 IN LINE 260 OF BipolarMotor.c: 'angle': unreferenced local variable
 444          
 445          void Display_Pos(float sign_dat)
 446          {
 447   1        unsigned char unit, ten, hundred,thousand;
 448   1        unsigned char after_dot;
 449   1        int dat;
 450   1        dat=abs(sign_dat);
 451   1        if (sign_dat>0)
 452   1          after_dot=(unsigned char)((sign_dat-dat)*10);
 453   1        else
 454   1          after_dot=(unsigned char)((-sign_dat-dat)*10);
 455   1        
 456   1        unit =dat%10;// remainder after division
 457   1        thousand=dat/1000;
 458   1        hundred=(dat-thousand*1000)/100;
 459   1        ten=(dat-thousand*1000-hundred*100)/10;
 460   1        if (sign_dat>=0)
 461   1        {
 462   2          WriteData(thousand|0x30);
 463   2          WriteData(hundred|0x30);
 464   2          WriteData(ten|0x30);
 465   2          WriteData(unit|0x30);
 466   2          WriteData(0x2E);//.
 467   2          WriteData((after_dot)|0x30);
 468   2          if(!selected_motor)
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      04/02/2019 16:58:40 PAGE 9   

 469   2          {
 470   3            WriteData(0x6D);//m
 471   3            WriteData(0x6D);//m
 472   3            WriteData(0x20);// "blank"
 473   3            //WriteData(0x20);// "blank"
 474   3            //WriteData(0x20);// "blank"
 475   3          }
 476   2          else
 477   2          {
 478   3            WriteData(0xDF);// "blank"
 479   3            WriteData(0x20);// "blank"
 480   3            WriteData(0x20);// "blank"
 481   3          }
 482   2        }
 483   1        else
 484   1        {
 485   2          
 486   2          WriteData(0x2D);// "-"
 487   2          WriteData(thousand|0x30);
 488   2          WriteData(hundred|0x30);
 489   2          WriteData(ten|0x30);
 490   2          WriteData(unit|0x30);
 491   2          WriteData(0x2E);//"."
 492   2          WriteData(after_dot|0x30);
 493   2          if(!selected_motor)
 494   2          {
 495   3            WriteData(0x6D);//m
 496   3            WriteData(0x6D);//m
 497   3            WriteData(0x20);// "blank"
 498   3            //WriteData(0x20);// "blank"
 499   3            //WriteData(0x20);// "blank"
 500   3          }
 501   2          else
 502   2          {
 503   3            WriteData(0xDF);// "blank"
 504   3            WriteData(0x20);// "blank"
 505   3            WriteData(0x20);// "blank"
 506   3          }
 507   2          //WriteData(0x6D);//m
 508   2          //WriteData(0x6D);//m
 509   2      
 510   2        }
 511   1        return;
 512   1      }
 513          
 514          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6695    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1313     361
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       6
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
